
//
	template<typename Number>
	concept NumericDataType = std::is_arithmetic_v<Number>;

	template<NumericDataType Number = uint64_t>
	class __x86i64Int
//
		__x86i64Int(const uint64_t val = 0) : __x86i64Int{ std::to_string(val) } {}
//
		__x86i64Int& operator++() // postfix inc
		{
			*this += 1;
			return *this;
		}
//
		__x86i64Int& operator++(int) // prefix inc
		{
			__x86i64Int temp(*this);
			++(*this);
			return temp;
		}
//
		// constructor
		__x86i64Int(const Number x = 0)
		{
			while (x > 0)
			{
				digits_.push_back(x % BASE);
				x /= BASE;
			}
			if (digits_.empty())
			{
				digits_.push_back(0);
			}
		}
// README.md
Example expressed as C++ Code

```c++

	// Create empty ProofStep[lineNumber][proofStep] vector to store proof
	std::vector<std::vector<std::string>> ProofStep;

 	// Instantiate Prover (module)
	EuclidProver<BracketType::CurlyBraces> Euclid;

	// Use chars, as opposed to std::strings, for efficiency and minor performance gains
	/* char */ std::string PlayerCharacterSideKick = "1";
	/* char */ std::string QuadUtilityVehicle = "1";
	/* char */ std::string VehicleDriveDisabled = "1";
	/* char */ std::string EuropaLAnd = "1";
	/* char */ std::string StyxRiver = "2";
	/* char */ std::string NotInEuropaLand = "2";
	/* char */ std::string OutOfStyxBoat = "4";

	// Add axioms
	Euclid.Axiom({"{", "1", "}","+","{", "1", "}","=","{", "2", "}"}); // axiom_0
	Euclid.Axiom({ "{", "2", "}","+","{", "2", "}","=","4" }); // axiom_1

	// Add supporting lemmas
	Euclid.Lemma({ "{", "1", "}","+","{", "0", "}","=","{", "1", "}" }); // lemma_0

	// Theorem to Prove
	const std::vector<std::string> Prove = { "{", "4", "}", "=", "{", "1", "}","+","{", "1", "}","+","{", "1", "}", "+", "{", "1", "}" };

	if (Euclid.Prove(Prove, ProofStep))
	{
		std::cout << "Proof found:\n";
		Euclid.PrintPath(ProofStep);
	}
	else
	{
		std::cout << "Proof failed\n";
	}

	// Optional Solver: Expand
	std::vector<std::vector<std::string>> ProofStep;
	if (Euclid.ProveViaExpand(Prove, ProofStep))
	{
		std::cout << "Proof via Expand:\n";
		Euclid.PrintPath(ProofStep);
	}
	else
	{
		std::cout << "Proof via Expand failed\n";
	}

	// Optional Solver: Reduce
	std::vector<std::vector<std::string>> ProofStep;
	if (Euclid.ProveViaReduce(Prove, ProofStep))
	{
		std::cout << "Proof via Reduce:\n";
		Euclid.PrintPath(ProofStep);
	}
	else
	{
		std::cout << "Proof via Reduce failed\n";
	}

	
```
//
template<NumericDataType NumberBase = uint64_t>
	NumberBase PowerUInt64(const NumberBase& ConstNumberRef, 
		const NumberBase& ConstExponentRef)
	{
		NumberBase result = NumberBase{ ConstNumberRef };
		NumberBase radix = NumberBase{ ConstExponentRef };
		while (radix--)
		{
			result *= ConstNumberRef;
		}
		return result;
	};
//
		static bool IsPrimeUInt64(const uint64_t& n)
		{
			if (n <= 1)
			{
				return false;
			}
			if (n <= 3)
			{
				return true;
			}
			if (n % 2 == 0 || n % 3 == 0)
			{
				return false;
			}
			for (uint64_t i = 5; i * i <= n; i += 6)
			{
				if (n % i == 0 || n % (i + 2) == 0)
				{
					return false;
				}
			}
			return true;
		}
//
		__x86i64Int operator*(const __x86i64Int& other) const
		{
			__x86i64Int result;
			result.digits_.resize(digits_.size() + other.digits_.size());
			for (uint64_t i = 0; i < digits_.size(); i++)
			{
				uint64_t carry = 0;
				for (uint64_t j = 0; j < other.digits_.size() || carry > 0; j++)
				{
					uint64_t prod = result.digits_[i + j] + 
						carry + 
						digits_[i] * 
						(j < other.digits_.size() ? other.digits_[j] : 0);
					result.digits_[i + j] = prod % BASE;
					carry = prod / BASE;
				}
			}
			result.trimLeadingZeros();
			result.sign_ = sign_ * other.sign_;
			return result;
		}
//
		__x86i64Int(const char* str) : __x86i64Int(std::string(str))
		{

		}
//
		bool Lemma(const std::vector<std::string>& InLemmaVecConstStdStringRef)
		{
			bool LemmaAcceptedFlag = false;
			const std::string& delim = "=";
			bool LeftHandSideFlag = true;
			std::vector<std::string> lhs{};
			std::vector<std::string> rhs{};
			bool FirstIndexFlag = false;
			uint64_t nCompositeIndexUInt64 = 0;
			for (const std::string& token : InLemmaVecConstStdStringRef)
			{
				if (FirstIndexFlag && LeftHandSideFlag)
				{
					LemmaLHSPrimeComposite.push_back(1); // lhs[0] == PrimeCompositeUInt64 //
					FirstIndexFlag = false;
				}
				if (token == delim)
				{
					LeftHandSideFlag = false;
					if (rhs.size() > 0)
					{
						LemmaRHS.push_back(rhs);
						rhs = {}; 
						nCompositeIndexUInt64++;
						LemmaRHSPrimeComposite.push_back(1);
					}
					continue;
				}
				if (!TokenLibraryStdStringToUInt64tMap.contains(token))
				{
					TokenLibraryStdStringToUInt64tMap.insert({ token,
						PrimeNumberGen::NextPrimeUInt64() });
				}
				if (LeftHandSideFlag)
				{
					lhs.push_back(token);
					LemmaLHSPrimeComposite[nCompositeIndexUInt64] *= TokenLibraryStdStringToUInt64tMap.at(token);
				}
				else
				{
					rhs.push_back(token);
					LemmaRHSPrimeComposite[nCompositeIndexUInt64] *= TokenLibraryStdStringToUInt64tMap.at(token);
				}
			}
			if (lhs.size() < 1 ||
				rhs.size() < 1)
			{
				std::cout << "Warning - Missing equals '=' in axiom or lemma. Axioms and lemmas must have 'lhs... = rhs...' layout." << std::endl;
				/* LemmaAcceptedFlag : false */ 
			}
			else
			{
				LemmaLHS.push_back(lhs);
				LemmaRHS.push_back(rhs);
				LemmaAcceptedFlag = true;
			}
			
			return LemmaAcceptedFlag;
		}
//
template<BracketType EuclidBracket>
	class API_EXPORT EuclidProver
	{
	public:
		explicit EuclidProver() : _openBrace { BracketTraits<EuclidBracket>::Open },
			_closeBrace{ BracketTraits<EuclidBracket>::Close }
		{
			/*
			static_assert(std::is_same_v<decltype(EuclidBracket), BracketType>, "Invalid bracket type");
			_openBrace = BracketTraits<EuclidBracket>::Open;
			_closeBrace = BracketTraits<EuclidBracket>::Close;*/
		}
		bool Axiom(const std::vector<char>& InAxiomVecConstCharRef) const
		{
			bool AxiomAcceptedFlag = false;
			return AxiomAcceptedFlag;
		}
		bool Axiom(const std::initializer_list<char>& InAxiomInitListConstCharRef) const
		{
			const std::vector<char>& InAxiomVecConstCharRef{ InAxiomInitListConstCharRef };
			return Axiom(InAxiomVecConstCharRef);
		}
		bool Lemma(const std::vector<char>& InLemmaVecConstCharRef) const
		{
			bool LemmaAcceptedFlag = false;
			return LemmaAcceptedFlag;
		}
		bool Lemma(const std::initializer_list<char>& InLemmaInitListConstCharRef) const
		{
			const std::vector<char>& InLemmaVecConstCharRef{ InLemmaInitListConstCharRef };
			return Lemma(InLemmaVecConstCharRef);
		}
		bool Prove(const std::vector<char>& InProofTargetVecConstCharRef,
			std::vector<std::vector<char>>& OutPath2DVecCharRef)
		{
			bool ResultFoundFlag = false;
			return ResultFoundFlag;
		}
		bool ProveViaReduce(const std::vector<char>& InProofTargetVecChar,
			std::vector<std::vector<char>>& OutReducePathVec2DCharRef)
		{
			bool ResultFoundFlag = false;
			return ResultFoundFlag;
		}
		bool ProveViaExpand(const std::vector<char>& InProofTargetVecConstChar,
			std::vector<std::vector<char>>& OutExpandPathVec2DCharRef)
		{
			bool ResultFoundFlag = false;
			return ResultFoundFlag;
		}
		void PrintPath(const std::vector<std::vector<char>>& InPathVec2DConstChar) const
		{

		}
	private:
		const char _openBrace;// = BracketTraits<EuclidBracket>::Open;
		const char _closeBrace;// = BracketTraits<EuclidBracket>::Close;
	};