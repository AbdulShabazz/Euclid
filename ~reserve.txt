//
		std::string to_string(const std::vector<uint64_t>& digits) const
		{
			//std::ostringstream oss;
			std::string value{};
			for (const auto& num : digits)
			{
				std::string temp = std::to_string(num);
				std::reverse(temp.begin(), temp.end());
				value += temp;
				//oss << num;
			}
			//std::string temp = oss.str();
			return value + "n";
		}
//
		std::string to_string(const std::vector<uint64_t>& digits) const
		{
			//std::ostringstream oss;
			std::string value{};
			for (const auto& num : digits)
			{
				std::string temp = std::to_string(num);
				std::reverse(temp.begin(), temp.end());
				value += temp;
				//oss << num;
			}
			//std::string temp = oss.str();
			return value + "n";
		}
//
		friend std::ostream& operator<< (std::ostream& os, const bool& value)
		{
			const std::string str = value ? "true" : "false";
			os << str;
			return os;
		}
//
		/*

		friend std::ostream& operator<< (std::ostream& os, const __x86i64Int& value)
		{
			const std::string str = value.to_string();
			os << str;
			return os;
		}*/
//
		virtual __x86i64Int operator- (const __x86i64Int& rhs) const
		{
			__x86i64Int result{ "0" };
			if (sign_ == rhs.sign_)
			{
				if (abs() >= rhs.abs())
				{
					result.digits_.resize(digits_.size());
					uint64_t borrow = 0;
					for (uint64_t i = uint64_t{ 0 }; i < result.digits_.size(); i++)
					{
						uint64_t diff = borrow + digits_[i];
						if (i < rhs.digits_.size())
						{
							diff -= rhs.digits_[i];
						}
						if (diff < 0)
						{
							diff += BASE;
							borrow = -1;
						}
						else
						{
							borrow = 0;
						}
						result.digits_[i] = diff;
					}
					result.trimLeadingZeros();
					result.sign_ = sign_;
				}
				else
				{
					result = -(rhs - *this);
				}
			}
			else
			{
				result = *this + (-rhs);
			}
			return result;
		}
//
		template <typename BoolOrTruthyType = bool>
		std::string is_bool_type(const T& value)
		{
			std::string result{ value };
			if constexpr (std::is_same_v<T, bool>)
			{
				result = value ? "true" : "false";
			}
			return result;
		}
//
		std::string to_string() const
		{
			std::string str{};
			for (auto it = digits_.rbegin(); it != digits_.rend(); ++it)
			{
				str += char(*it + '0');
			}
			return str;
		}
//
		std::string to_string(const std::vector<uint64_t>& digits) const
		{
			std::string str{};
			for (auto it = digits.rbegin(); it != digits.rend(); ++it)
			{
				str += char(*it + '0');
			}
			return str;
		}
//
		virtual __x86i64Int operator* (const __x86i64Int& rhs) const
		{
			__x86i64Int result;
			// Resize the result vector to fit the result
			result.digits_.resize(digits_.size() + rhs.digits_.size());
			// Perform multiplication digit by digit
			for (uint64_t i = 0; i < digits_.size(); ++i)
			{
				uint64_t carry = 0;
				for (uint64_t j = 0; j < rhs.digits_.size() || carry; ++j)
				{
					uint64_t product = result.digits_[i + j] + carry +
					(j < rhs.digits_.size()) ? digits_[i] * rhs.digits_[j] : 0ull;
					result.digits_[i + j] = product % BASE;
					carry = product / BASE;
				}
			}
			// Preserve the sign of the result
			result.sign_ = sign_ * rhs.sign_;
			// Remove leading zeros
			result.trimLeadingZeros();
			return result;
		}
//
		// Constructor
		__x86i64Int(const std::string& str = "0")
		{
			for (auto it = str.rbegin(); it != str.rend(); ++it)
			{
				if (std::isdigit(*it))
				{
					digits_.push_back(*it - '0');
				}
				else if (*it == '-')
				{
					sign_ = -1;
				}
			}
			if (digits_.empty())
			{
				digits_.push_back(0);
			}
			trimLeadingZeros();
		}
//
		__x86i64Int GetNumberSubrange(size_t start_index, const size_t& length) const
		{
			__x86i64Int SubrangeSliceUInt64{ "0" };
			if (start_index >= digits_.size()) 
			{
				// NOP //
			}
			else
			{
				const __x86i64Int I = _min(
					__x86i64Int{ std::to_string(start_index + length) }, 
					__x86i64Int{ std::to_string(digits_.size()) });
				__x86i64Int StartIndex{ std::to_string(start_index) };
				for (__x86i64Int i = StartIndex; i < I; i++)
				{
					SubrangeSliceUInt64.digits_.push_back(digits_[i]);
				}
			}
			return SubrangeSliceUInt64;
		}
//


		__x86i64Int operator%= (const __x86i64Int& rhs)
		{
			if (rhs == __x86i64Int{ "0" })
			{
				throw std::invalid_argument("Division by zero");
			}
			// Compute the remainder using long division algorithm
			__x86i64Int dividend = *this;
			__x86i64Int divisor = rhs.abs();
			__x86i64Int quotient{ "0" };
			__x86i64Int remainder{ "0" };
			const size_t I = static_cast<size_t>(dividend.digits_.size() - 1);
			for (size_t i = I; i > 0; i--)
			{
				remainder *= __x86i64Int{ std::to_string(BASE) };
				remainder += __x86i64Int{ std::to_string(dividend.digits_[i - 1]) };
				const __x86i64Int& result = remainder / divisor;
				PushAtFront(quotient, result.quotient());
				remainder %= divisor;
			}
			std::reverse(quotient.digits_.begin(), quotient.digits_.end());
			std::reverse(remainder.digits_.begin(), remainder.digits_.end());
			__x86i64Int result = *this = remainder;
			return result;
		}
//
		__x86i64Int operator/ (const __x86i64Int& rhs) const
		{
			if (rhs == __x86i64Int{ "0" })
			{
				throw std::invalid_argument("divide by zero");
			}
			__x86i64Int result{ "0" };
			__x86i64Int remainder{ "0" };
			result.digits_.resize(digits_.size());
			for (int64_t i = digits_.size() - 1; i >= 0; i--)
			{
				remainder = remainder * __x86i64Int{ std::to_string(BASE) } + __x86i64Int{ std::to_string(digits_[i]) };
				int x = 0, y = BASE - 1;
				while (x < y)
				{
					int m = (x + y + 1) / 2;
					if (rhs * __x86i64Int{ std::to_string(m) } <= remainder)
					{
						x = m;
					}
					else
					{
						y = m - 1;
					}
				}
				result.digits_[i] = x;
				remainder -= rhs * __x86i64Int{ std::to_string(x) };
			}
			result.trimLeadingZeros();
			result.sign_ = sign_ * rhs.sign_;
			return result;
		}
//
		/** Knuth implementation...
		Example:
		__x86i64Int dividend{ 12n }, divisor{ 12n };
		std::pair<__x86i64Int, __x86i64Int> result = dividend / divisor;
		__x86i64Int quotient = result.first;
		__x86i64Int remainder = result.second;
		*/
		std::pair<__x86i64Int, __x86i64Int> operator/ (const __x86i64Int& divisor)
		{ 

			__x86i64Int dividend{ *this };
			__x86i64Int quotient{};
			__x86i64Int remainder{};

			// Step 1. Handle base cases

			// Base case 1: Division by zero
			if (divisor.digits_.empty())
			{
				throw std::runtime_error("Divide by zero");
			}

			// Base case 2: Dividend is smaller than the divisor
			if (dividend < divisor)
			{
				return std::make_pair(quotient, remainder); // Return zero as the quotient
			}

			// Base case 6: Dividend is a multiple of the divisor
			if (dividend == divisor)
			{
				quotient.digits_.push_back(1);
				return std::make_pair(quotient, remainder);
			}

			// Base case 3: Divisor is a single-digit number
			if (divisor.digits_.size() == 1)
			{
				int single_digit = divisor.digits_[0];
				return dividend.DivideByDigit(single_digit);
			}

			// Base case 4: Dividend is a single-digit number
			if (dividend.digits_.size() == 1)
			{
				int single_digit = dividend.digits_[0];
				quotient.digits_.push_back(single_digit / divisor.digits_[0]);
				remainder = __x86i64Int{ std::to_string(single_digit % divisor.digits_[0]) };
				return std::make_pair(quotient, remainder);
			}

			// Base case 5: Dividend is a power of 10
			if (dividend.digits_.size() > divisor.digits_.size() &&
				dividend.digits_.back() == 0)
			{
				quotient.digits_.resize(dividend.digits_.size() - divisor.digits_.size(), 0);
				dividend.digits_.resize(divisor.digits_.size());
			}

			// Base case 7: Dividend is a power of 10 and a multiple of the divisor
			if (dividend.digits_.size() == divisor.digits_.size() &&
				dividend.digits_.back() == 0)
			{
				quotient.digits_.resize(dividend.digits_.size() - divisor.digits_.size(), 0);
				dividend.digits_.resize(divisor.digits_.size());
			}

			// Step 2: Normalize dividend and divisor
			/*
			This implementation multiplies both the dividend and divisor by a normalization factor 
			to ensure the divisor's most significant digit is greaterThan or equalTo 5 
			so that the divisor's most significant digit is greater than or equal to half the base 
			(in our case, base 10). Normalization helps improve the efficiency and accuracy 
			of the quotient estimation in the algorithm... 
			The normalization factor is calculated as 10 / (1 + divisor.digits_.back()).
			*/
			int normalization_factor = 10 / (1 + divisor.digits_.back());
			__x86i64Int normalized_dividend = dividend * __x86i64Int{ std::to_string(normalization_factor) };
			__x86i64Int normalized_divisor = divisor * __x86i64Int{ std::to_string(normalization_factor) };

			// Step 3: Determine the number of chunks and create a loop to iterate through them
			uint64_t n = uint64_t{ normalized_dividend.digits_.size() };
			uint64_t m = uint64_t{ normalized_divisor.digits_.size() };
			uint64_t chunk_count = n - m;

			quotient.digits_.resize(chunk_count + 1, 0);

			// Loop through chunks in reverse (from most significant to least significant)
			for (int64_t i = chunk_count; i >= 0; i--)
			{
				// Step 4: Estimate the quotient using the most significant digits
				int q_clamp = int{ normalized_dividend.digits_[i + m] * 10 +
					normalized_dividend.digits_[i + m - 1] } /
					int{ normalized_divisor.digits_[m - 1] };

				// Clamp the estimate to the maximum value of a single digit (9)
				if (q_clamp > 9)
				{
					q_clamp = 9;
				}

				// Step 5: Refine the estimated quotient and compute the remainder
				__x86i64Int r_clamp = normalized_dividend.GetNumberSubrange(i, m + 1) - __x86i64Int{ std::to_string(q_clamp) } * normalized_divisor;

				// Adjust the estimate if necessary
				while (r_clamp.sign_ < 1)
				{
					q_clamp--;
					r_clamp += normalized_divisor;
				}

				// Update the dividend with the remainder
				normalized_dividend.SetNumberSubrange(i, r_clamp);

				// Save the quotient for this chunk
				quotient.digits_[i] = q_clamp;
			}

			// Step 6: Finalize the quotient
			quotient.trimLeadingZeros();

			return std::make_pair(quotient, remainder);
		}
//
		// Constructor
		template <typename T = std::string,
		typename std::enable_if<!std::is_arithmetic<T>::value, int>::type = 0>
		__x86i64Int(const T& str = "0")
		{
			for (T it = str.rbegin(); it != str.rend(); ++it)
			{
				if (std::isdigit(*it))
				{
					digits_.push_back(*it - '0');
				}
				else if (*it == '-')
				{
					sign_ = -1;
				}
			}
			if (digits_.empty())
			{
				digits_.push_back(0);
			}
			trimLeadingZeros();
		}
//
		__x86i64Int operator* (const __x86i64Int& other) const
		{
			auto rowProductVecUInt64 = [](const __x86i64Int& InDigitsVecUInt64Ref,
				const int& InOtherUIntRef,
				__x86i64Int& OutResultVecUInt64Ref)
			{
				int carry = 0;
				const uint64_t& J = OutResultVecUInt64Ref.digits_.size();
				for (uint64_t j = 0; ((j < J) || (carry > 0)); j++)
				{
					int prod = carry +
						OutResultVecUInt64Ref.digits_[j] +
						InOtherUIntRef *
						(j < InDigitsVecUInt64Ref.digits_.size() ?
							InDigitsVecUInt64Ref.digits_[j] : int{ 0 });
					OutResultVecUInt64Ref.digits_[j] = prod % BASE;
					carry = static_cast<int>(prod / BASE);
				}
			};

			std::vector<__x86i64Int> IntermediateResultVecUInt64;
			const uint64_t I = digits_.size();
			const uint64_t II = digits_.size() + other.digits_.size();

			// Initialize thread pool with a fixed number of threads
			const size_t MaxConcurrentThreads = std::thread::hardware_concurrency();
			bool useThreadPoolFlag = (MaxConcurrentThreads > 2U);
			const size_t numThreads = (useThreadPoolFlag ? MaxConcurrentThreads : 2U) - 1;
			std::vector<std::future<void>> futures;

			for (uint64_t i = 0; i < I; i++)
			{
				__x86i64Int temp{ "0" };
				temp.digits_.resize(II, 0);
				IntermediateResultVecUInt64.push_back(temp);
			}

			auto processChunk = [&](uint64_t start, uint64_t end)
			{
				for (uint64_t i = start; i < end; i++)
				{
					rowProductVecUInt64(*this, other.digits_[i], IntermediateResultVecUInt64[i]);
				}
			};

			for (size_t i = 0; i < numThreads; ++i)
			{
				uint64_t startIndex = (I * i) / numThreads;
				uint64_t endIndex = (I * (i + 1)) / numThreads;
				futures.push_back(std::async(std::launch::async, processChunk, startIndex, endIndex));
			}

			for (auto& future : futures)
			{
				future.wait();
			}

			SumArrayRefInParallel(IntermediateResultVecUInt64);
			IntermediateResultVecUInt64[0].trimLeadingZeros();
			IntermediateResultVecUInt64[0].sign_ = sign_ * other.sign_;
			return IntermediateResultVecUInt64[0];
		}
//
		bool CalculatePrimeComposites(const std::vector<std::vector<std::string>>& InLHS,
			std::vector<uint64_t>& OutLHSPrimeComposite,
			const std::vector<std::vector<std::string>>& InRHS,
			std::vector<uint64_t>& OutRHSPrimeComposite)
		{
			bool ResultFlag = false;

			const uint64_t I =  InLHS.size();
			uint64_t LHSPrimeCompositeUInt64 = 1;

			for (uint64_t i = 0; i < I; i++)
			{
				const uint64_t J = InLHS[i].size();
				for (uint64_t j = 0; j < J; j++)
				{
					LHSPrimeCompositeUInt64 *= GetPrimeUInt64(InLHS[i][j]);
				}
				OutLHSPrimeComposite.push_back(LHSPrimeCompositeUInt64);
				LHSPrimeCompositeUInt64 = 1;
			}

			uint64_t RHSPrimeCompositeUInt64 = 1;
			const uint64_t II = InRHS.size();

			for (uint64_t ii = 0; ii < II; ii++)
			{
				const uint64_t JJ = InRHS[ii].size();
				for (uint64_t jj = 0; jj < JJ; jj++)
				{
					RHSPrimeCompositeUInt64 *= GetPrimeUInt64(InRHS[ii][jj]);
				}
				OutRHSPrimeComposite.push_back(RHSPrimeCompositeUInt64);
				RHSPrimeCompositeUInt64 = 1;
			}

			ResultFlag = true;
			return ResultFlag;
		}
//
		bool SplitEquation(const std::vector<std::string>& InAxiomConstStdStrVecRef,
			uint64_t& OutAxiomLHSPrimeCompositeUInt64,
			uint64_t& OutAxiomRHSPrimeCompositeUInt64,
			std::vector<std::vector<std::string>>& OutAxiomRHS,
			std::vector<std::vector<std::string>>& OutAxiomLHS,
			std::vector<uint64_t>& OutAxiomRHSPrimeComposite,
			std::vector<uint64_t>& OutAxiomLHSPrimeComposite)
		{
			bool result = false;
			bool FoundEqualsSignFlag = false;
			bool NoOpenBracesFlag = true;
			int openBraces = 0;
			const std::unordered_map <std::string, bool> AssignmentOP = { { "=", true}, {"==>", true}, {"<==", true}, {"<==>", true} };
			for (const std::string& str : InAxiomConstStdStrVecRef)
			{
				if (AssignmentOP.find(str) != AssignmentOP.end())
				{
					FoundEqualsSignFlag = true;
					if (rhs.size())
					{
						OutAxiomRHS.push_back(rhs);
						OutAxiomRHSPrimeComposite.push_back(OutAxiomRHSPrimeCompositeUInt64);
						OutAxiomRHSPrimeCompositeUInt64 = 1;
						rhs = {};
					}
					continue;
				}
				if (!FoundEqualsSignFlag) 
				{
					lhs.push_back(str); 
					const uint64_t prime = GetPrimeUInt64(str);
					const uint64_t ExponentUInt64 = static_cast<uint64_t>(lhs.size());
					const uint64_t PowerUInt64 = std::PowerUInt64<>(prime, ExponentUInt64);
					OutAxiomLHSPrimeCompositeUInt64 *= PowerUInt64;
				}
				else
				{
					rhs.push_back(str);
					const uint64_t prime = GetPrimeUInt64(str);
					const uint64_t ExponentUInt64 = static_cast<uint64_t>(rhs.size());
					const uint64_t PowerUInt64 = std::PowerUInt64<>(prime, ExponentUInt64);
					OutAxiomRHSPrimeCompositeUInt64 *= PowerUInt64;
				}
			}
			return result;
		}
	};
//
			int lhsOpenBraces = 0;
			int rhsOpenBraces = 0;
			auto countOpenBraces = [](const std::vector<std::string>& ConstStdStringVecRef,
				int& openBraces,
				const std::string& OpenBrace,
				const std::string& OpenBraceST,
				const std::string& CloseBrace)
			{
				std::unordered_set<std::string> braceSet{ OpenBrace, OpenBraceST };				
				for (const std::string& str : ConstStdStringVecRef)
				{
					if (braceSet.contains(str))
					{
						openBraces++;
					}
					else if (str == CloseBrace)
					{
						openBraces--;
					}
				}
			};
			/*
			std::thread lhsThread(countOpenBraces, 
				std::cref(lhs), 
				std::ref(lhsOpenBraces),
				std::cref(_openBrace),
				std::cref(_closeBrace));
			std::thread rhsThread(countOpenBraces, 
				std::cref(rhs), 
				std::ref(rhsOpenBraces),
				std::cref(_openBrace),
				std::cref(_closeBrace));
			lhsThread.join();
			rhsThread.join();
			*/
			// Implicit: NoOpenBracesFlag = true;
			if (lhsOpenBraces || rhsOpenBraces)
			{
				std::cout << "Warning - Axioms must have atleast one '=' operator and lemmas must have one or more '=' '==>' '<==' or '<==>'" << std::endl;
				NoOpenBracesFlag = false;
			}
			return (NoOpenBracesFlag && FoundEqualsSignFlag);
//
	class API_EXPORT CurlyBraceScopeChecker
	{
	public:
		/**
		Example:
		std::vector<std::string> stringvec_ = { "{", "}", "{", "{", "}", "}" };
		CurlyBraceScopeChecker::AreProperlyScoped<BracketType::CurlyBraces>(stringvec_); // returns true 
		*/
		template <BracketType type>
		static bool AreProperlyScoped(const std::vector<std::string>& chars)
		{
			static_assert(std::is_same_v<decltype(type), BracketType>, "Invalid bracket type");
			const char openBrace = BracketTraits<type>::Open;
			const char closeBrace = BracketTraits<type>::Close;
			int count = 0;
			for (char c : chars)
			{
				if (c == openBrace)
				{
					count++;
				}
				else if (c == closeBrace)
				{
					count--;
				}
			}
			return count == 0;
		}
	};
//
	// Maintain a log2 of the prime composite.
	uint64_t log2PrimeComposite = 0;

	// Calculate the log2 of the first 160 primes.
	std::vector<uint64_t> log2Primes{};

	constexpr uint64_t InitPrimeComposite (const std::vector<uint64_t>& _primes)
	{
		uint64_t result = 1;
		uint64_t log2val = 0;
		for (const uint64_t& val : _primes)
		{
			result *= val;
			log2val = log2(val);
			log2Primes.push_back(log2val);
			log2PrimeComposite += log2val;
		}
		return result;
	};

	uint64_t PrimeCompositeUInt64 = InitPrimeComposite(primes);
//
		// Usage: Ideally { lhs } is in expanded-form (eg. { 2 } + { 2 } ) and { rhs } is in reduced-form (eg. { 4 } )
//
		__x86i64Int&& operator*(const __x86i64Int& other) const
		{
			auto rowProductVecUInt64 = [](const __x86i64Int& InDigitsVecUInt64Ref,
				const int& InOtherUIntRef,
				__x86i64Int& OutResultVecUInt64Ref)
			{
				int carry = 0;
				const uint64_t& J = OutResultVecUInt64Ref.digits_.size();
				for (uint64_t j = 0; ((j < J) || (carry > 0)); j++)
				{
					int prod = carry + 
						OutResultVecUInt64Ref.digits_[j] + 
						InOtherUIntRef * 
						(j < InDigitsVecUInt64Ref.digits_.size() ? 
							InDigitsVecUInt64Ref.digits_[j] : int{ 0 });
					OutResultVecUInt64Ref.digits_[j] = prod % BASE;
					carry = static_cast<int>(prod / BASE);
				}
			};
			std::vector<__x86i64Int> IntermediateResultVecUInt64;
			std::vector<thread> FusedMultiplyAddThread;
			const uint64_t I = digits_.size();
			const uint64_t II = digits_.size() + other.digits_.size();
			for (uint64_t i = 0; i < I; i++)
			{
				__x86i64Int temp{ "0" };
				temp.digits_.resize(II, 0);
				IntermediateResultVecUInt64.push_back(temp);
				FusedMultiplyAddThread.push_back(
					std::thread(rowProductVecUInt64, 
						std::cref(*this), 
						std::cref(other.digits_[i]),
						std::ref(IntermediateResultVecUInt64[i])));
			}
			for (thread& th : FusedMultiplyAddThread)
			{
				th.join();
			}
			SumArrayRefInParallel(IntermediateResultVecUInt64);
			IntermediateResultVecUInt64[0].trimLeadingZeros();
			IntermediateResultVecUInt64[0].sign_ = sign_ * other.sign_;
			return std::move(IntermediateResultVecUInt64[0]);
		}
//
		// Conversion operator to std::size_t
		operator std::size_t&&() const
		{
			// Assuming you have a method or member variable that represents the value
			// Return the value as std::size_t for the conversion
			size_t i = 0;
			size_t ret = 0;
			std::vector<int> result = digits_;
			std::reverse(result.begin(), result.end());
			for (const int& val : result)
			{
				ret += val * PowerUInt64<size_t>(BASE, i++);
			}
			return std::move(ret);
		}
//
		bool _assign(uint64_t& InStartIndexConstUInt64Ref, const __x86i64Int& InConstObjUInt64Ref)
		{
			bool AssignedFlag = false;
			if (InStartIndexConstUInt64Ref)
			{
				throw std::runtime_error("Negative index");
			}
			if (InConstObjUInt64Ref.digits_.size() - InStartIndexConstUInt64Ref > digits_.size())
			{
				throw std::runtime_error("Startindex plus object length exceeds Endindex");
			}
			if (InStartIndexConstUInt64Ref >= digits_.size())
			{
				throw std::runtime_error("Start/End index exceeds vector length");
			}
			else if (InStartIndexConstUInt64Ref + InConstObjUInt64Ref.digits_.size >= digits_.size())
			{

			}
			uint64_t& StartIndexInt64 = InStartIndexConstUInt64Ref;
			const uint64_t& EndIndexInt64 = InParam2UInt64;
			__x86i64Int ret{ "0" };
			ret.digits_.resize(EndIndexInt64 - StartIndexInt64 + 1);
			for (int& val : ret.digits_)
			{
				val = digits_[StartIndexInt64++];
			}
			return ret;
		}
//
		EuclidProver() : _openBrace{ "{" },
			_closeBrace{ "}" }
		{

		}
//
		__x86i64Int(const std::string& str = "0")
		{
			std::vector<std::thread> threads;
			auto processDigit = [&](const auto digit, vector<uint64_t>& OutVecRef, const int& i)
			{
				OutVecRef[i] = digit - '0';
			};
			digits_.resize(str.size(), 0);
			uint64_t i = 0;
			for (auto it = str.rbegin(); it != str.rend(); ++it)
			{
				if (*it >= '0' && *it <= '9')
				{
					threads.emplace_back([&] {
						processDigit(*it, digits_, i++);
						});
				}
				else if (*it == '-')
				{
					sign_ = -1;
				}
			}
			for (auto& thread : threads)
			{
				thread.join();
			}
			if (digits_.empty())
			{
				digits_.push_back(0);
			}
			trimLeadingZeros();
		}
//
	__x86i64Int(const std::string& str = "0")
		{
			std::for_each(std::execution::par, str.rbegin(), str.rend(), [&](char c) {
				if (c >= '0' && c <= '9')
				{
					digits_.push_back(c - '0');
				}
				else if (c == '-')
				{
					sign_ = -1;
				}
				});
			if (digits_.empty())
			{
				digits_.push_back(0);
			}
			trimLeadingZeros();
		}
//
		__x86i64Int(const std::string& str = "0")
		{
			std::vector<std::thread> threads; 
			auto processDigit = [&](char digit, int& val) {
				int value = digit - '0';
				for (size_t i = 0; i < digits_.size(); i++)
				{
					int result = digits_[i] * value;
					digits_[i] = result % 10;
					if (i + 1 == digits_.size())
					{
						digits_.push_back(result / 10);
					}
					else
					{
						digits_[i + 1] += result / 10;
					}
				}
			};
			digits_.resize(str.size(), 0);
			uint64_t i = 0;
			for (auto it = str.rbegin(); it != str.rend(); ++it)
			{
				if (*it >= '0' && *it <= '9')
				{
					digits_.push_back(*it - '0');
					threads.emplace_back([=] {
						processDigit(*it, digits_[i++]);
						});
				}
				else if (*it == '-')
				{
					sign_ = -1;
				}
			}
			if (digits_.empty())
			{
				digits_.push_back(0);
			}
			for (auto& thread : threads)
			{
				thread.join();
			}
			trimLeadingZeros();
		}
//
		__x86i64Int(const std::string& str = "0")
		{
			std::vector<std::thread> threads; 
			auto processDigit = [&](char digit) {
				int value = digit - '0';
				for (size_t i = 0; i < digits_.size(); i++)
				{
					int result = digits_[i] * value;
					digits_[i] = result % 10;
					if (i + 1 == digits_.size())
					{
						digits_.push_back(result / 10);
					}
					else
					{
						digits_[i + 1] += result / 10;
					}
				}
			};
			for (auto it = str.rbegin(); it != str.rend(); ++it)
			{
				if (*it >= '0' && *it <= '9')
				{
					digits_.push_back(*it - '0');
					threads.emplace_back([=] {
						processDigit(*it);
						});
				}
				else if (*it == '-')
				{
					sign_ = -1;
				}
			}
			if (digits_.empty())
			{
				digits_.push_back(0);
			}
			for (auto& thread : threads)
			{
				thread.join();
			}
			trimLeadingZeros();
		}
//
		__x86i64Int(const std::string& str = "0")
		{
			for (auto it = str.rbegin(); it != str.rend(); ++it)
			{
				if (*it >= '0' && *it <= '9')
				{
					digits_.push_back(*it - '0');
				}
				else if (*it == '-')
				{
					sign_ = -1;
				}
			}
			if (digits_.empty())
			{
				digits_.push_back(0);
			}
			trimLeadingZeros();
		}
//
		__x86i64Int(const uint64_t val = 0) : __x86i64Int{ std::to_string(val) } {}
//
	auto parallelSum = [&](const std::vector<__x86i64Int>& input,
				std::vector<__x86i64Int>& output,
				const uint64_t& start,
				const uint64_t& end) -> void
			{
				if (start == end)
				{
					output[start] = input[start];
					return;
				}
				uint64_t mid = (start + end) / 2;
				std::vector<__x86i64Int> left_output{ mid - start + 1 };
				std::vector<__x86i64Int> right_output{ end - mid };
				auto left_fn = [&]() { parallelSum(input, left_output, start, mid); };
				auto right_fn = [&]() { parallelSum(input, right_output, mid + 1, end); };
				std::thread left_thread(left_fn);
				std::thread right_thread(right_fn, std::cref(input), std::ref(right_output), mid + 1, end);
				left_thread.join();
				right_thread.join();
				std::merge(left_output.begin(), left_output.end(),
					right_output.begin(), right_output.end(),
					output.begin() + start);
				const uint64_t& I = end + 1;
				for (uint64_t& i = start; i < I; i++)
				{
					output[start] += output[i];
				}
			};
//
			auto parallelSum = [](const std::vector<__x86i64Int>& input,
				std::vector<__x86i64Int>& output,
				const uint64_t& start,
				const uint64_t& end) -> void
			{
				if (start == end)
				{
					output[start] = input[start];
					return;
				}
				uint64_t mid = (start + end) / 2;
				std::vector<__x86i64Int> left_output{ mid - start + 1 };
				std::vector<__x86i64Int> right_output{ end - mid };
				std::thread left_thread(parallelSum, std::cref(input), std::ref(left_output), start, mid);
				std::thread right_thread(parallelSum, std::cref(input), std::ref(right_output), mid + 1, end);
				left_thread.join();
				right_thread.join();
				std::merge(left_output.begin(), left_output.end(),
					right_output.begin(), right_output.end(),
					output.begin() + start);
				const uint64_t& I = end + 1;
				for (uint64_t& i = start; i < I; i++)
				{
					output[start] += output[i];
				}
			};
//
		void parallelSum(const std::vector<__x86i64Int>& input,
			std::vector<__x86i64Int>& output,
			uint64_t start,
			uint64_t end) const
		{
			if (start == end)
			{
				output[start] = input[start];
				return;
			}

			uint64_t mid = (start + end) / 2;
			std::vector<__x86i64Int> left_output{ mid - start + 1 };
			std::vector<__x86i64Int> right_output{ end - mid };

			std::thread left_thread(parallelSum, std::cref(input), std::ref(left_output), start, mid);
			std::thread right_thread(parallelSum, std::cref(input), std::ref(right_output), mid + 1, end);

			left_thread.join();
			right_thread.join();

			std::merge(left_output.begin(), left_output.end(),
				right_output.begin(), right_output.end(),
				output.begin() + start);

			const uint64_t& I = end + 1;
			for (uint64_t& i = start; i < I; i++)
			{
				output[start] += output[i];
			}
		}
//
		template<typename... Args>
		requires (std::is_same_v<__x86i64Int, Args...>, "Second arguments... must be of type int")
		bool _pushFront(__x86i64Int& x, Args&... args)
		{
			bool NoErrorsFlag = true;
			for(const int& digit : args)
			{
				if (digit >= 0 && digit < BASE)
				{
					x.digits_.insert(x.digits_.begin(), digit...);
				}
				else
				{
					NoErrorsFlag = false;
					continue;
				}
			}
			return NoErrorsFlag;
		}
//
		template<typename... Args>
		requires (std::is_same_v<__x86i64Int, Args...>, "All arguments must be of type __x86i64Int") // or C++17 static_assert( std::is_same_v<__x86i64Int, Args...>, "All arguments must be of type __x86i64Int" )
		__x86i64Int& _min(const __x86i64Int& arg, const Args&... args) const
		{
			__x86i64Int result{ arg };
			for (const __x86i64Int& val : args)
			{
				if (val < result)
				{
					result = val;
				}
			}
			return result;
		}
//
	template<typename... Args>
		requires (std::is_same_v<uint64_t, Args...>, "Arguments must be of type uint64_t")
		uint64_t& _max(const uint64_t& arg, const Args&... args) const
		{
			uint64_t result = arg;
			for (const uint64_t& val : args)
			{
				if (val > result)
				{
					result = val;
				}
			}
			return result;
		}
//
		bool operator<(const __x86i64Int& other) const
		{
			bool resultFlag = true;
			if (sign_ != other.sign_)
			{
				resultFlag = (sign_ < other.sign_);
			}
			else if (digits_.size() != other.digits_.size())
			{
				resultFlag = (digits_.size() * sign_ < other.digits_.size() * other.sign_);
			}
			else
			{
				for (uint64_t i = digits_.size() - 1; i >= 0; i--)
				{
					if (digits_[i] != other.digits_[i])
					{
						resultFlag = (digits_[i] * sign_ < other.digits_[i] * other.sign_);
						break;
					}
				}
			}
			return resultFlag;
		}
//
	template<typename Number>
	concept NumericDataType = std::is_arithmetic_v<Number>;

	template<NumericDataType Number = uint64_t>
	class __x86i64Int
//
		__x86i64Int(const uint64_t val = 0) : __x86i64Int{ std::to_string(val) } {}
//
		__x86i64Int& operator++() // postfix inc
		{
			*this += 1;
			return *this;
		}
//
		__x86i64Int& operator++(int) // prefix inc
		{
			__x86i64Int temp(*this);
			++(*this);
			return temp;
		}
//
		// constructor
		__x86i64Int(const Number x = 0)
		{
			while (x > 0)
			{
				digits_.push_back(x % BASE);
				x /= BASE;
			}
			if (digits_.empty())
			{
				digits_.push_back(0);
			}
		}
// README.md
Example expressed as C++ Code

```c++

	// Create empty ProofStep[lineNumber][proofStep] vector to store proof
	std::vector<std::vector<std::string>> ProofStep;

 	// Instantiate Prover (module)
	EuclidProver<BracketType::CurlyBraces> Euclid;

	// Use chars, as opposed to std::strings, for efficiency and minor performance gains
	/* char */ std::string PlayerCharacterSideKick = "1";
	/* char */ std::string QuadUtilityVehicle = "1";
	/* char */ std::string VehicleDriveDisabled = "1";
	/* char */ std::string EuropaLAnd = "1";
	/* char */ std::string StyxRiver = "2";
	/* char */ std::string NotInEuropaLand = "2";
	/* char */ std::string OutOfStyxBoat = "4";

	// Add axioms
	Euclid.Axiom({"{", "1", "}","+","{", "1", "}","=","{", "2", "}"}); // axiom_0
	Euclid.Axiom({ "{", "2", "}","+","{", "2", "}","=","4" }); // axiom_1

	// Add supporting lemmas
	Euclid.Lemma({ "{", "1", "}","+","{", "0", "}","=","{", "1", "}" }); // lemma_0

	// Theorem to Prove
	const std::vector<std::string> Prove = { "{", "4", "}", "=", "{", "1", "}","+","{", "1", "}","+","{", "1", "}", "+", "{", "1", "}" };

	if (Euclid.Prove(Prove, ProofStep))
	{
		std::cout << "Proof found:\n";
		Euclid.PrintPath(ProofStep);
	}
	else
	{
		std::cout << "Proof failed\n";
	}

	// Optional Solver: Expand
	std::vector<std::vector<std::string>> ProofStep;
	if (Euclid.ProveViaExpand(Prove, ProofStep))
	{
		std::cout << "Proof via Expand:\n";
		Euclid.PrintPath(ProofStep);
	}
	else
	{
		std::cout << "Proof via Expand failed\n";
	}

	// Optional Solver: Reduce
	std::vector<std::vector<std::string>> ProofStep;
	if (Euclid.ProveViaReduce(Prove, ProofStep))
	{
		std::cout << "Proof via Reduce:\n";
		Euclid.PrintPath(ProofStep);
	}
	else
	{
		std::cout << "Proof via Reduce failed\n";
	}

	
```
//
template<NumericDataType NumberBase = uint64_t>
	NumberBase PowerUInt64(const NumberBase& ConstNumberRef, 
		const NumberBase& ConstExponentRef)
	{
		NumberBase result = NumberBase{ ConstNumberRef };
		NumberBase radix = NumberBase{ ConstExponentRef };
		while (radix--)
		{
			result *= ConstNumberRef;
		}
		return result;
	};
//
		static bool IsPrimeUInt64(const uint64_t& n)
		{
			if (n <= 1)
			{
				return false;
			}
			if (n <= 3)
			{
				return true;
			}
			if (n % 2 == 0 || n % 3 == 0)
			{
				return false;
			}
			for (uint64_t i = 5; i * i <= n; i += 6)
			{
				if (n % i == 0 || n % (i + 2) == 0)
				{
					return false;
				}
			}
			return true;
		}
//
		__x86i64Int operator*(const __x86i64Int& other) const
		{
			__x86i64Int result;
			result.digits_.resize(digits_.size() + other.digits_.size());
			for (uint64_t i = 0; i < digits_.size(); i++)
			{
				uint64_t carry = 0;
				for (uint64_t j = 0; j < other.digits_.size() || carry > 0; j++)
				{
					uint64_t prod = result.digits_[i + j] + 
						carry + 
						digits_[i] * 
						(j < other.digits_.size() ? other.digits_[j] : 0);
					result.digits_[i + j] = prod % BASE;
					carry = prod / BASE;
				}
			}
			result.trimLeadingZeros();
			result.sign_ = sign_ * other.sign_;
			return result;
		}
//
		__x86i64Int(const char* str) : __x86i64Int(std::string(str))
		{

		}
//
		bool Lemma(const std::vector<std::string>& InLemmaVecConstStdStringRef)
		{
			bool LemmaAcceptedFlag = false;
			const std::string& delim = "=";
			bool LeftHandSideFlag = true;
			std::vector<std::string> lhs{};
			std::vector<std::string> rhs{};
			bool FirstIndexFlag = false;
			uint64_t nCompositeIndexUInt64 = 0;
			for (const std::string& token : InLemmaVecConstStdStringRef)
			{
				if (FirstIndexFlag && LeftHandSideFlag)
				{
					LemmaLHSPrimeComposite.push_back(1); // lhs[0] == PrimeCompositeUInt64 //
					FirstIndexFlag = false;
				}
				if (token == delim)
				{
					LeftHandSideFlag = false;
					if (rhs.size() > 0)
					{
						LemmaRHS.push_back(rhs);
						rhs = {}; 
						nCompositeIndexUInt64++;
						LemmaRHSPrimeComposite.push_back(1);
					}
					continue;
				}
				if (!TokenLibraryStdStringToUInt64tMap.contains(token))
				{
					TokenLibraryStdStringToUInt64tMap.insert({ token,
						PrimeNumberGen::NextPrimeUInt64() });
				}
				if (LeftHandSideFlag)
				{
					lhs.push_back(token);
					LemmaLHSPrimeComposite[nCompositeIndexUInt64] *= TokenLibraryStdStringToUInt64tMap.at(token);
				}
				else
				{
					rhs.push_back(token);
					LemmaRHSPrimeComposite[nCompositeIndexUInt64] *= TokenLibraryStdStringToUInt64tMap.at(token);
				}
			}
			if (lhs.size() < 1 ||
				rhs.size() < 1)
			{
				std::cout << "Warning - Missing equals '=' in axiom or lemma. Axioms and lemmas must have 'lhs... = rhs...' layout." << std::endl;
				/* LemmaAcceptedFlag : false */ 
			}
			else
			{
				LemmaLHS.push_back(lhs);
				LemmaRHS.push_back(rhs);
				LemmaAcceptedFlag = true;
			}
			
			return LemmaAcceptedFlag;
		}
//
template<BracketType EuclidBracket>
	class API_EXPORT EuclidProver
	{
	public:
		explicit EuclidProver() : _openBrace { BracketTraits<EuclidBracket>::Open },
			_closeBrace{ BracketTraits<EuclidBracket>::Close }
		{
			/*
			static_assert(std::is_same_v<decltype(EuclidBracket), BracketType>, "Invalid bracket type");
			_openBrace = BracketTraits<EuclidBracket>::Open;
			_closeBrace = BracketTraits<EuclidBracket>::Close;*/
		}
		bool Axiom(const std::vector<char>& InAxiomVecConstCharRef) const
		{
			bool AxiomAcceptedFlag = false;
			return AxiomAcceptedFlag;
		}
		bool Axiom(const std::initializer_list<char>& InAxiomInitListConstCharRef) const
		{
			const std::vector<char>& InAxiomVecConstCharRef{ InAxiomInitListConstCharRef };
			return Axiom(InAxiomVecConstCharRef);
		}
		bool Lemma(const std::vector<char>& InLemmaVecConstCharRef) const
		{
			bool LemmaAcceptedFlag = false;
			return LemmaAcceptedFlag;
		}
		bool Lemma(const std::initializer_list<char>& InLemmaInitListConstCharRef) const
		{
			const std::vector<char>& InLemmaVecConstCharRef{ InLemmaInitListConstCharRef };
			return Lemma(InLemmaVecConstCharRef);
		}
		bool Prove(const std::vector<char>& InProofTargetVecConstCharRef,
			std::vector<std::vector<char>>& OutPath2DVecCharRef)
		{
			bool ResultFoundFlag = false;
			return ResultFoundFlag;
		}
		bool ProveViaReduce(const std::vector<char>& InProofTargetVecChar,
			std::vector<std::vector<char>>& OutReducePathVec2DCharRef)
		{
			bool ResultFoundFlag = false;
			return ResultFoundFlag;
		}
		bool ProveViaExpand(const std::vector<char>& InProofTargetVecConstChar,
			std::vector<std::vector<char>>& OutExpandPathVec2DCharRef)
		{
			bool ResultFoundFlag = false;
			return ResultFoundFlag;
		}
		void PrintPath(const std::vector<std::vector<char>>& InPathVec2DConstChar) const
		{

		}
	private:
		const char _openBrace;// = BracketTraits<EuclidBracket>::Open;
		const char _closeBrace;// = BracketTraits<EuclidBracket>::Close;
	};