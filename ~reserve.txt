
//
		static bool IsPrimeUInt64(const uint64_t& n)
		{
			if (n <= 1)
			{
				return false;
			}
			if (n <= 3)
			{
				return true;
			}
			if (n % 2 == 0 || n % 3 == 0)
			{
				return false;
			}
			for (uint64_t i = 5; i * i <= n; i += 6)
			{
				if (n % i == 0 || n % (i + 2) == 0)
				{
					return false;
				}
			}
			return true;
		}
//
		__x86i64Int operator*(const __x86i64Int& other) const
		{
			__x86i64Int result;
			result.digits_.resize(digits_.size() + other.digits_.size());
			for (uint64_t i = 0; i < digits_.size(); i++)
			{
				uint64_t carry = 0;
				for (uint64_t j = 0; j < other.digits_.size() || carry > 0; j++)
				{
					uint64_t prod = result.digits_[i + j] + 
						carry + 
						digits_[i] * 
						(j < other.digits_.size() ? other.digits_[j] : 0);
					result.digits_[i + j] = prod % BASE;
					carry = prod / BASE;
				}
			}
			result.trimLeadingZeros();
			result.sign_ = sign_ * other.sign_;
			return result;
		}
//
		__x86i64Int(const char* str) : __x86i64Int(std::string(str))
		{

		}
//
		bool Lemma(const std::vector<std::string>& InLemmaVecConstStdStringRef)
		{
			bool LemmaAcceptedFlag = false;
			const std::string& delim = "=";
			bool LeftHandSideFlag = true;
			std::vector<std::string> lhs{};
			std::vector<std::string> rhs{};
			bool FirstIndexFlag = false;
			uint64_t nCompositeIndexUInt64 = 0;
			for (const std::string& token : InLemmaVecConstStdStringRef)
			{
				if (FirstIndexFlag && LeftHandSideFlag)
				{
					LemmaLHSPrimeComposite.push_back(1); // lhs[0] == PrimeCompositeUInt64 //
					FirstIndexFlag = false;
				}
				if (token == delim)
				{
					LeftHandSideFlag = false;
					if (rhs.size() > 0)
					{
						LemmaRHS.push_back(rhs);
						rhs = {}; 
						nCompositeIndexUInt64++;
						LemmaRHSPrimeComposite.push_back(1);
					}
					continue;
				}
				if (!TokenLibraryStdStringToUInt64tMap.contains(token))
				{
					TokenLibraryStdStringToUInt64tMap.insert({ token,
						PrimeNumberGen::NextPrimeUInt64() });
				}
				if (LeftHandSideFlag)
				{
					lhs.push_back(token);
					LemmaLHSPrimeComposite[nCompositeIndexUInt64] *= TokenLibraryStdStringToUInt64tMap.at(token);
				}
				else
				{
					rhs.push_back(token);
					LemmaRHSPrimeComposite[nCompositeIndexUInt64] *= TokenLibraryStdStringToUInt64tMap.at(token);
				}
			}
			if (lhs.size() < 1 ||
				rhs.size() < 1)
			{
				std::cout << "Warning - Missing equals '=' in axiom or lemma. Axioms and lemmas must have 'lhs... = rhs...' layout." << std::endl;
				/* LemmaAcceptedFlag : false */ 
			}
			else
			{
				LemmaLHS.push_back(lhs);
				LemmaRHS.push_back(rhs);
				LemmaAcceptedFlag = true;
			}
			
			return LemmaAcceptedFlag;
		}
//
template<BracketType EuclidBracket>
	class API_EXPORT EuclidProver
	{
	public:
		explicit EuclidProver() : _openBrace { BracketTraits<EuclidBracket>::Open },
			_closeBrace{ BracketTraits<EuclidBracket>::Close }
		{
			/*
			static_assert(std::is_same_v<decltype(EuclidBracket), BracketType>, "Invalid bracket type");
			_openBrace = BracketTraits<EuclidBracket>::Open;
			_closeBrace = BracketTraits<EuclidBracket>::Close;*/
		}
		bool Axiom(const std::vector<char>& InAxiomVecConstCharRef) const
		{
			bool AxiomAcceptedFlag = false;
			return AxiomAcceptedFlag;
		}
		bool Axiom(const std::initializer_list<char>& InAxiomInitListConstCharRef) const
		{
			const std::vector<char>& InAxiomVecConstCharRef{ InAxiomInitListConstCharRef };
			return Axiom(InAxiomVecConstCharRef);
		}
		bool Lemma(const std::vector<char>& InLemmaVecConstCharRef) const
		{
			bool LemmaAcceptedFlag = false;
			return LemmaAcceptedFlag;
		}
		bool Lemma(const std::initializer_list<char>& InLemmaInitListConstCharRef) const
		{
			const std::vector<char>& InLemmaVecConstCharRef{ InLemmaInitListConstCharRef };
			return Lemma(InLemmaVecConstCharRef);
		}
		bool Prove(const std::vector<char>& InProofTargetVecConstCharRef,
			std::vector<std::vector<char>>& OutPath2DVecCharRef)
		{
			bool ResultFoundFlag = false;
			return ResultFoundFlag;
		}
		bool ProveViaReduce(const std::vector<char>& InProofTargetVecChar,
			std::vector<std::vector<char>>& OutReducePathVec2DCharRef)
		{
			bool ResultFoundFlag = false;
			return ResultFoundFlag;
		}
		bool ProveViaExpand(const std::vector<char>& InProofTargetVecConstChar,
			std::vector<std::vector<char>>& OutExpandPathVec2DCharRef)
		{
			bool ResultFoundFlag = false;
			return ResultFoundFlag;
		}
		void PrintPath(const std::vector<std::vector<char>>& InPathVec2DConstChar) const
		{

		}
	private:
		const char _openBrace;// = BracketTraits<EuclidBracket>::Open;
		const char _closeBrace;// = BracketTraits<EuclidBracket>::Close;
	};