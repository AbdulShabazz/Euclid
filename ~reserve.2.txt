
                const bool lhs_mod_lhs_flag = Theorem[LHS] % Axiom[LHS] == 0;
                const bool lhs_mod_rhs_flag = Theorem[LHS] % Axiom[RHS] == 0;
                const bool rhs_mod_lhs_flag = Theorem[RHS] % Axiom[LHS] == 0;
                const bool rhs_mod_rhs_flag = Theorem[RHS] % Axiom[RHS] == 0;
                
                const bool lhs_call_lhs_flag = CallHistory[ Theorem[LHS] ][ Axiom[LHS] ] == false;
                const bool lhs_call_rhs_flag = CallHistory[ Theorem[LHS] ][ Axiom[RHS] ] == false;
                const bool rhs_call_lhs_flag = CallHistory[ Theorem[RHS] ][ Axiom[LHS] ] == false;
                const bool rhs_call_rhs_flag = CallHistory[ Theorem[RHS] ][ Axiom[RHS] ] == false;
//
                uint16_t flags = 0;

                flags |= (Theorem[LHS] % Axiom[LHS] == 0) << 0;
                flags |= (Theorem[LHS] % Axiom[RHS] == 0) << 1;
                flags |= (Theorem[RHS] % Axiom[LHS] == 0) << 2;
                flags |= (Theorem[RHS] % Axiom[RHS] == 0) << 3;
                
                flags |= (CallHistory[Theorem[LHS]][Axiom[LHS]] == false) << 4;
                flags |= (CallHistory[Theorem[LHS]][Axiom[RHS]] == false) << 5;
                flags |= (CallHistory[Theorem[RHS]][Axiom[LHS]] == false) << 6;
                flags |= (CallHistory[Theorem[RHS]][Axiom[RHS]] == false) << 7;
                
                switch (flags)
                {
                    case (0b10001): // lhs_mod_lhs_flag && lhs_call_lhs_flag
                        break;
                    case (0b01010): // lhs_mod_rhs_flag && lhs_call_rhs_flag
                        break;
                    case (0b001100): // rhs_mod_lhs_flag && rhs_call_lhs_flag
                        break;
                    case (0b00001000): // rhs_mod_rhs_flag && rhs_call_rhs_flag
                        break;
                    default:
                        break;
                }
//
#include <iostream>
#include <thread>
#include <atomic>
#include <cstdint>
#include <cstdlib>
#include <array>
#include <chrono>
#include <vector>
#include <deque>
#include <string>
#include <unordered_map>

int main()
{
    const auto start_time_chrono = std::chrono::high_resolution_clock::now();

    /*
    token: [ "1" "2" "4" "+" ]
    prime: [  2   3   5   7 ]
    */
    
    bool QED {};

    const uint64_t N = 2; // Update as needed;

    std::array < uint64_t, 2 > Axioms_Vec;

    //std::unordered_map <uint64_t, Axiom_Struct> Axioms_LibraryMap;
    
    std::array<uint64_t, 2> Theorem_UInt64Vec = 
    {
        5488, // "1 + 1 + 1 + 1"
        5 // "4"
    };

    std::vector<std::array<uint64_t, 2>> Axioms_UInt64Vec = 
    {
        {
            28, // "1 + 1"
            3 // "2"
        },

        {
            63, // "2 + 2"
            5 // "4"
        }
    };
    
    std::deque<
    std::array<uint64_t, 2 >> Tasks_Thread;
    
    Tasks_Thread.push_back ( Theorem_UInt64Vec );
    
    constexpr int LHS = 0;
    constexpr int RHS = 1;

    constexpr uint64_t MaxAllowedProofs_UInt64{ 1 };
    uint64_t TotalProofsFound_UInt64 {};
    
    std::unordered_map<uint64_t,
    std::unordered_map<uint64_t,bool>> CallHistory {};
    
    while (!Tasks_Thread.empty() && !QED)
    {
        std::array<uint64_t, 2 > Theorem = 
        Tasks_Thread.front();
        Tasks_Thread.pop_front();
        
        if (Theorem[LHS] == Theorem[RHS])
        {
            std::cout << std::endl;
            std::cout << "Proof Found" << std::endl;
            std::cout << "Theorem_0000 {" << Theorem[LHS] << ", " << Theorem[RHS] << "}" << std::endl;
            std::cout << std::endl;
            std::cout << "Q.E.D." << std::endl;
            
          ++TotalProofsFound_UInt64;
            if (TotalProofsFound_UInt64 >= MaxAllowedProofs_UInt64)
            {
                QED = true;
                break;
            }
            
        } else {
            
            for (const std::array<uint64_t,2>& Axiom : Axioms_UInt64Vec)
            {
                const bool lhs_mod_lhs_flag = Theorem[LHS] % Axiom[LHS] == 0;
                const bool lhs_mod_rhs_flag = Theorem[LHS] % Axiom[RHS] == 0;
                const bool rhs_mod_lhs_flag = Theorem[RHS] % Axiom[LHS] == 0;
                const bool rhs_mod_rhs_flag = Theorem[RHS] % Axiom[RHS] == 0;
                
                const bool lhs_call_lhs_flag = CallHistory[ Theorem[LHS] ][ Axiom[LHS] ] == false;
                const bool lhs_call_rhs_flag = CallHistory[ Theorem[LHS] ][ Axiom[RHS] ] == false;
                const bool rhs_call_lhs_flag = CallHistory[ Theorem[RHS] ][ Axiom[LHS] ] == false;
                const bool rhs_call_rhs_flag = CallHistory[ Theorem[RHS] ][ Axiom[RHS] ] == false;
                
                if (lhs_mod_lhs_flag && lhs_call_lhs_flag)
                {
                    CallHistory[ Theorem[LHS] ][ Axiom[LHS] ] = true;
                    
                    std::array<uint64_t, 2> Theorem_0000 = Theorem;
                    Theorem_0000[LHS] = Theorem_0000[LHS] / Axiom[LHS] * Axiom[RHS];
                    std::cout << "Theorem_0000 {" << Theorem_0000[LHS] << ", " << Theorem_0000[RHS] << "}" << std::endl;
                    
                    //Tasks_Thread[Write].emplace_back(Theorem_0000);
                    Tasks_Thread.push_back ( Theorem_0000 );
                }
                else
                if (lhs_mod_rhs_flag && lhs_call_rhs_flag)
                {
                    CallHistory[ Theorem[LHS] ][ Axiom[RHS] ] = true;
                    
                    std::array<uint64_t, 2> Theorem_0000 = Theorem;
                    Theorem_0000[LHS] = Theorem_0000[LHS] / Axiom[RHS] * Axiom[LHS];
                    std::cout << "Theorem_0000 {" << Theorem_0000[LHS] << ", " << Theorem_0000[RHS] << "}" << std::endl;
                    
                    //Tasks_Thread[Write].emplace_back(Theorem_0000);
                    Tasks_Thread.push_back ( Theorem_0000 );
                }
                else
                if (rhs_mod_lhs_flag && rhs_call_lhs_flag)
                {
                    CallHistory[ Theorem[RHS] ][ Axiom[LHS] ] = true;
                    
                    std::array<uint64_t, 2> Theorem_0000 = Theorem;
                    Theorem_0000[RHS] = Theorem_0000[RHS] / Axiom[LHS] * Axiom[RHS];
                    std::cout << "Theorem_0000 {" << Theorem_0000[LHS] << ", " << Theorem_0000[RHS] << "}" << std::endl;
                    
                    //Tasks_Thread[Write].emplace_back(Theorem_0000);
                    Tasks_Thread.push_back ( Theorem_0000 );
                }
                else
                if (rhs_mod_rhs_flag && rhs_call_rhs_flag)
                {
                    CallHistory[ Theorem[RHS] ][ Axiom[RHS] ] = true;
                    
                    std::array<uint64_t, 2> Theorem_0000 = Theorem;
                    Theorem_0000[RHS] = Theorem_0000[RHS] / Axiom[RHS] * Axiom[LHS];
                    std::cout << "Theorem_0000 {" << Theorem_0000[LHS] << ", " << Theorem_0000[RHS] << "}" << std::endl;
                    
                    //Tasks_Thread[Write].emplace_back(Theorem_0000);
                    Tasks_Thread.push_back ( Theorem_0000 );
                }
            } // end for (...Axiom : Axioms_UInt64Vec)
        } // end for (...Theorem : Tasks_Thread[Read])
        
    } // end for (...!Tasks_Thread[Read].empty() && !QED))
    
    if (!QED)
    {   
        std::cout << "No Proof Found." << std::endl;
    }

    const auto end_time_chrono = std::chrono::high_resolution_clock::now();
    const auto duration_chrono = std::chrono::duration_cast<std::chrono::nanoseconds>(end_time_chrono - start_time_chrono).count();
    std::cout << "Total Duration (nanoseconds): " << duration_chrono << std::endl;

    return EXIT_SUCCESS;
}

//

// Define a linked list to store the tasks.
struct Task {
  uint64_t lhs;
  uint64_t rhs;
  Task* next;
};

// Define a function to search the linked list for the next task.
Task* FindNextTask(Task* head) {
  if (head == nullptr) {
    return nullptr;
  }

  // Use a binary search to find the next task.
  Task* current = head;
  Task* previous = nullptr;
  while (current != nullptr) {
    if (current->lhs == lhs && current->rhs == rhs) {
      return current;
    }
    previous = current;
    current = current->next;
  }

  // If no task was found, return nullptr.
  return nullptr;
};

// Define a function to perform the proofs.
bool PerformProof(uint64_t lhs, uint64_t rhs, const std::vector<uint64_t>& axioms) {
  // Use a backtracking algorithm to perform the proofs.
  for (uint64_t i = 0; i < axioms.size(); i++) {
    if (lhs % axioms[i] == 0) {
      lhs /= axioms[i];
      rhs *= axioms[i];
      if (lhs == rhs) {
        return true;
      }
    }
  }

  // If no proof was found, return false.
  return false;
};

// Main function.
int main() {
  // Create a linked list to store the tasks.
  Task* head = nullptr;

  // Add some tasks to the linked list.
  head = new Task();
  head->lhs = 1;
  head->rhs = 2;
  head->next = new Task();
  head->next->lhs = 3;
  head->next->rhs = 4;
  head->next->next = nullptr;

  // Search the linked list for the next task.
  Task* current = FindNextTask(head);

  // If a task was found, perform the proof.
  if (current != nullptr) {
    if (PerformProof(current->lhs, current->rhs, axioms)) {
      std::cout << "Proof found!" << std::endl;
    } else {
      std::cout << "No proof found." << std::endl;
    }
  } else {
    std::cout << "No tasks found." << std::endl;
  }

  // Free the linked list.
  while (head != nullptr) {
    Task* next = head->next;
    delete head;
    head = next;
  }

  return EXIT_SUCCESS;
}
//
#include <vector>

using namespace std;

int main() {
  // Create a vector of tasks.
  vector<array<uint64_t, 2>> tasks;

  // Create a vector of axioms.
  vector<array<uint64_t, 2>> axioms;

  // Iterate over the tasks and axioms.
  for (const auto& task : tasks) {
    for (const auto& axiom : axioms) {
      // Check for a match.
      if (task[LHS] == axiom[LHS] || task[LHS] == axiom[RHS] || task[RHS] == axiom[LHS] || task[RHS] == axiom[RHS]) {
        // Print the theorem.
        cout << "Theorem_0000 {" << task[LHS] << ", " << task[RHS] << "}" << endl;
      }
    }
  }

  return 0;
}

//
#include <iostream>
#include <thread>
#include <atomic>
#include <cstdint>
#include <cstdlib>
#include <array>
#include <chrono>
#include <vector>
#include <string>
#include <unordered_map>

struct NextRound_Struct
{
    bool Round_Flag {};
    bool init_flag {};
    
    uint8_t iCurrentRound_UInt8 = 0;
    uint8_t iNextRound_UInt8 = 1;

    uint8_t NextRound_UInt8 (const bool UpdateRound_Flag = true)
    {
        if(UpdateRound_Flag && init_flag)
            std::swap (iCurrentRound_UInt8,iNextRound_UInt8);
            
        init_flag = true;

        return iNextRound_UInt8;
    };

    uint8_t CurrentRound_UInt8 ()
    {
        return iCurrentRound_UInt8;
    };
};

int main()
{
    const auto start_time_chrono = std::chrono::high_resolution_clock::now();

    /*
    token: [ "1" "2" "4" "+" ]
    prime: [  2   3   5   7 ]
    */
    
    NextRound_Struct Round;
    
    bool QED {};

    const uint64_t N = 2; // Update as needed;

    std::array < uint64_t, 2 > Axioms_Vec;

    //std::unordered_map <uint64_t, Axiom_Struct> Axioms_LibraryMap;
    
    std::array<uint64_t, 2> Theorem_UInt64Vec = 
    {
        5488, // "1 + 1 + 1 + 1"
        5 // "4"
    };

    std::vector<std::array<uint64_t, 2>> Axioms_UInt64Vec = 
    {
        {
            28, // "1 + 1"
            3 // "2"
        },

        {
            63, // "2 + 2"
            5 // "4"
        }
    };

    std::array < std::vector < std::array<uint64_t, 2 > >, 2 > Tasks_Thread = {};
    
    Tasks_Thread[0].emplace_back(Theorem_UInt64Vec);
    
    constexpr int LHS = 0;
    constexpr int RHS = 1;

    constexpr uint64_t MaxAllowedProofs_UInt64{ 1 };
    uint64_t TotalProofsFound_UInt64 {};
    
    uint8_t Write = Round.NextRound_UInt8();
    uint8_t Read = Round.CurrentRound_UInt8();
    
    std::unordered_map<uint64_t,
    std::unordered_map<uint64_t,bool>> CallHistory {};
    
    while (!Tasks_Thread[Read].empty() && !QED)
    {
        for (const std::array<uint64_t, 2>& Theorem: Tasks_Thread[Read])
        {
            for (const std::array<uint64_t,2>& Axiom : Axioms_UInt64Vec)
            {
                if (Theorem[LHS] == Theorem[RHS])
                {
                    std::cout << std::endl;
                    std::cout << "Proof Found" << std::endl;
                    std::cout << "Theorem_0000 {" << Theorem[LHS] << ", " << Theorem[RHS] << "}" << std::endl;
                    std::cout << std::endl;
                    std::cout << "Q.E.D." << std::endl;
                    
                  ++TotalProofsFound_UInt64;
                    if (TotalProofsFound_UInt64 >= MaxAllowedProofs_UInt64)
                    {
                        QED = true;
                        break;
                    }
                }
            
                if (QED)
                {
                    break;
                } else {
                    
                    if (Theorem[LHS] % Axiom[LHS] == 0)
                    {
                        //CallHistory[ Theorem[LHS] ][ Axiom[LHS] ] = true;
                        
                        std::array<uint64_t, 2> Theorem_0000 = Theorem;
                        Theorem_0000[LHS] = Theorem_0000[LHS] / Axiom[LHS] * Axiom[RHS];
                        std::cout << "Theorem_0000 {" << Theorem_0000[LHS] << ", " << Theorem_0000[RHS] << "}" << std::endl;
                        
                        Tasks_Thread[Write].emplace_back(Theorem_0000);
                    }
                    else
                    if (Theorem[LHS] % Axiom[RHS] == 0)
                    {
                        //CallHistory[ Theorem[LHS] ][ Axiom[RHS] ] = true;
                        
                        std::array<uint64_t, 2> Theorem_0000 = Theorem;
                        Theorem_0000[LHS] = Theorem_0000[LHS] / Axiom[RHS] * Axiom[LHS];
                        std::cout << "Theorem_0000 {" << Theorem_0000[LHS] << ", " << Theorem_0000[RHS] << "}" << std::endl;
                        
                        Tasks_Thread[Write].emplace_back(Theorem_0000);
                    }
                    else
                    if (Theorem[RHS] % Axiom[LHS] == 0)
                    {
                        //CallHistory[ Theorem[RHS] ][ Axiom[LHS] ] = true;
                        
                        std::array<uint64_t, 2> Theorem_0000 = Theorem;
                        Theorem_0000[RHS] = Theorem_0000[RHS] / Axiom[LHS] * Axiom[RHS];
                        std::cout << "Theorem_0000 {" << Theorem_0000[LHS] << ", " << Theorem_0000[RHS] << "}" << std::endl;
                        
                        Tasks_Thread[Write].emplace_back(Theorem_0000);
                    }
                    else
                    if (Theorem[RHS] % Axiom[RHS] == 0)
                    {
                        //CallHistory[ Theorem[RHS] ][ Axiom[RHS] ] = true;
                        
                        std::array<uint64_t, 2> Theorem_0000 = Theorem;
                        Theorem_0000[RHS] = Theorem_0000[RHS] / Axiom[RHS] * Axiom[LHS];
                        std::cout << "Theorem_0000 {" << Theorem_0000[LHS] << ", " << Theorem_0000[RHS] << "}" << std::endl;
                        
                        Tasks_Thread[Write].emplace_back(Theorem_0000);
                    }
                    else
                    if (
                    Theorem[LHS] % Axiom[LHS] == 0 &&
                    Theorem[RHS] % Axiom[LHS] == 0)
                    {
                    	std::array<uint64_t, 2> Theorem_0000 = Theorem;
                    
                    	Theorem_0000[LHS] = Theorem_0000[LHS] / Axiom[LHS] * Axiom[RHS];
                    	Theorem_0000[RHS] = Theorem_0000[RHS] / Axiom[LHS] * Axiom[RHS];
                    	std::cout << "Theorem_0000 {" << Theorem_0000[LHS] << ", " << Theorem_0000[RHS] << "}" << std::endl;
                    
                    	Tasks_Thread[Write].emplace_back(Theorem_0000);
                    }
                                        else
                    if (
                    Theorem[LHS] % Axiom[LHS] == 0 &&
                    Theorem[RHS] % Axiom[RHS] == 0)
                    {
                    	std::array<uint64_t, 2> Theorem_0000 = Theorem;
                    
                    	Theorem_0000[LHS] = Theorem_0000[LHS] / Axiom[LHS] * Axiom[RHS];
                    	Theorem_0000[RHS] = Theorem_0000[RHS] / Axiom[RHS] * Axiom[LHS];
                    	std::cout << "Theorem_0000 {" << Theorem_0000[LHS] << ", " << Theorem_0000[RHS] << "}" << std::endl;
                    
                    	Tasks_Thread[Write].emplace_back(Theorem_0000);
                    }
                                        else
                    if (
                    Theorem[LHS] % Axiom[RHS] == 0 &&
                    Theorem[RHS] % Axiom[LHS] == 0)
                    {
                    	std::array<uint64_t, 2> Theorem_0000 = Theorem;
                    
                    	Theorem_0000[LHS] = Theorem_0000[LHS] / Axiom[RHS] * Axiom[LHS];
                    	Theorem_0000[RHS] = Theorem_0000[RHS] / Axiom[LHS] * Axiom[RHS];
                    	std::cout << "Theorem_0000 {" << Theorem_0000[LHS] << ", " << Theorem_0000[RHS] << "}" << std::endl;
                    
                    	Tasks_Thread[Write].emplace_back(Theorem_0000);
                    }
                                        else
                    if (
                    Theorem[LHS] % Axiom[RHS] == 0 &&
                    Theorem[RHS] % Axiom[RHS] == 0)
                    {
                    	std::array<uint64_t, 2> Theorem_0000 = Theorem;
                    
                    	Theorem_0000[LHS] = Theorem_0000[LHS] / Axiom[RHS] * Axiom[LHS];
                    	Theorem_0000[RHS] = Theorem_0000[RHS] / Axiom[RHS] * Axiom[LHS];
                    	std::cout << "Theorem_0000 {" << Theorem_0000[LHS] << ", " << Theorem_0000[RHS] << "}" << std::endl;
                    
                    	Tasks_Thread[Write].emplace_back(Theorem_0000);
                    }
                                        else
                    if (
                    Theorem[RHS] % Axiom[LHS] == 0 &&
                    Theorem[LHS] % Axiom[LHS] == 0)
                    {
                    	std::array<uint64_t, 2> Theorem_0000 = Theorem;
                    
                    	Theorem_0000[RHS] = Theorem_0000[RHS] / Axiom[LHS] * Axiom[RHS];
                    	Theorem_0000[LHS] = Theorem_0000[LHS] / Axiom[LHS] * Axiom[RHS];
                    	std::cout << "Theorem_0000 {" << Theorem_0000[LHS] << ", " << Theorem_0000[RHS] << "}" << std::endl;
                    
                    	Tasks_Thread[Write].emplace_back(Theorem_0000);
                    }
                                        else
                    if (
                    Theorem[RHS] % Axiom[LHS] == 0 &&
                    Theorem[LHS] % Axiom[RHS] == 0)
                    {
                    	std::array<uint64_t, 2> Theorem_0000 = Theorem;
                    
                    	Theorem_0000[RHS] = Theorem_0000[RHS] / Axiom[LHS] * Axiom[RHS];
                    	Theorem_0000[LHS] = Theorem_0000[LHS] / Axiom[RHS] * Axiom[LHS];
                    	std::cout << "Theorem_0000 {" << Theorem_0000[LHS] << ", " << Theorem_0000[RHS] << "}" << std::endl;
                    
                    	Tasks_Thread[Write].emplace_back(Theorem_0000);
                    }
                                        else
                    if (
                    Theorem[RHS] % Axiom[RHS] == 0 &&
                    Theorem[LHS] % Axiom[LHS] == 0)
                    {
                    	std::array<uint64_t, 2> Theorem_0000 = Theorem;
                    
                    	Theorem_0000[RHS] = Theorem_0000[RHS] / Axiom[RHS] * Axiom[LHS];
                    	Theorem_0000[LHS] = Theorem_0000[LHS] / Axiom[LHS] * Axiom[RHS];
                    	std::cout << "Theorem_0000 {" << Theorem_0000[LHS] << ", " << Theorem_0000[RHS] << "}" << std::endl;
                    
                    	Tasks_Thread[Write].emplace_back(Theorem_0000);
                    }
                                        else
                    if (
                    Theorem[RHS] % Axiom[RHS] == 0 &&
                    Theorem[LHS] % Axiom[RHS] == 0)
                    {
                    	std::array<uint64_t, 2> Theorem_0000 = Theorem;
                    
                    	Theorem_0000[RHS] = Theorem_0000[RHS] / Axiom[RHS] * Axiom[LHS];
                    	Theorem_0000[LHS] = Theorem_0000[LHS] / Axiom[RHS] * Axiom[LHS];
                    	std::cout << "Theorem_0000 {" << Theorem_0000[LHS] << ", " << Theorem_0000[RHS] << "}" << std::endl;
                    
                    	Tasks_Thread[Write].emplace_back(Theorem_0000);
                    }

                } // end test (QED)
            } // end for (...Axiom : Axioms_UInt64Vec)
            
            if (QED)
            {
                break;
            } 
        } // end for (...Theorem : Tasks_Thread[Read])
    
        Tasks_Thread[Read] = {};
        
        Write = Round.NextRound_UInt8 ();
        Read = Round.CurrentRound_UInt8 ();
    } // end while (Tasks_Thread[Read].size() && !QED)
    
    if (!QED)
    {   
        std::cout << "No Proof Found." << std::endl;
    }

    const auto end_time_chrono = std::chrono::high_resolution_clock::now();
    const auto duration_chrono = std::chrono::duration_cast<std::chrono::nanoseconds>(end_time_chrono - start_time_chrono).count();
    std::cout << "Total Duration (nanoseconds): " << duration_chrono << std::endl;

    return EXIT_SUCCESS;
}



//
#include <iostream>
#include <thread>
#include <atomic>
#include <cstdint>
#include <cstdlib>
#include <array>
#include <chrono>
#include <vector>
#include <string>
#include <unordered_map>

struct NextRound_Struct
{
    bool Round_Flag {};
    bool init_flag {};
    
    uint8_t iCurrentRound_UInt8 = 0;
    uint8_t iNextRound_UInt8 = 1;

    uint8_t NextRound_UInt8 (const bool UpdateRound_Flag = true)
    {
        if(UpdateRound_Flag && init_flag)
            std::swap (iCurrentRound_UInt8,iNextRound_UInt8);
            
        init_flag = true;

        return iNextRound_UInt8;
    };

    uint8_t CurrentRound_UInt8 ()
    {
        return iCurrentRound_UInt8;
    };
};

int main()
{
    const auto start_time_chrono = std::chrono::high_resolution_clock::now();

    /*
    token: [ "1" "2" "4" "+" ]
    prime: [  2   3   5   7 ]
    */
    
    NextRound_Struct Round;
    
    bool QED {};

    const uint64_t N = 2; // Update as needed;

    std::array < uint64_t, 2 > Axioms_Vec;

    //std::unordered_map <uint64_t, Axiom_Struct> Axioms_LibraryMap;
    
    std::array<uint64_t, 2> Theorem_UInt64Vec = 
    {
        5488, // "1 + 1 + 1 + 1"
        5 // "4"
    };

    std::vector<std::array<uint64_t, 2>> Axioms_UInt64Vec = 
    {
        {
            28, // "1 + 1"
            3 // "2"
        },

        {
            63, // "2 + 2"
            5 // "4"
        }
    };

    std::array < std::vector < std::array<uint64_t, 2 > >, 2 > Tasks_Thread = {};
    
    Tasks_Thread[0].emplace_back(Theorem_UInt64Vec);
    
    constexpr int LHS = 0;
    constexpr int RHS = 1;

    constexpr uint64_t MaxAllowedProofs_UInt64{ 1 };
    uint64_t TotalProofsFound_UInt64 {};
    
    uint8_t Write = Round.NextRound_UInt8();
    uint8_t Read = Round.CurrentRound_UInt8();
    
    std::unordered_map<uint64_t,
    std::unordered_map<uint64_t,bool>> CallHistory {};
    
    while (!Tasks_Thread[Read].empty() && !QED)
    {
        for (const std::array<uint64_t, 2>& Theorem: Tasks_Thread[Read])
        {
            for (const std::array<uint64_t,2>& Axiom : Axioms_UInt64Vec)
            {
                if (Theorem[LHS] == Theorem[RHS])
                {
                    std::cout << std::endl;
                    std::cout << "Proof Found" << std::endl;
                    std::cout << "Theorem_0000 {" << Theorem[LHS] << ", " << Theorem[RHS] << "}" << std::endl;
                    std::cout << std::endl;
                    std::cout << "Q.E.D." << std::endl;
                    
                  ++TotalProofsFound_UInt64;
                    if (TotalProofsFound_UInt64 >= MaxAllowedProofs_UInt64)
                    {
                        QED = true;
                        break;
                    }
                }
            
                if (QED)
                {
                    break;
                } else {
                    
                    if (
                        Theorem[LHS] % Axiom[LHS] == 0 &&
                        CallHistory[ Theorem[LHS] ][ Axiom[LHS] ] == 
                        false)
                    {
                        CallHistory[ Theorem[LHS] ][ Axiom[LHS] ] = true;
                        
                        std::array<uint64_t, 2> Theorem_0000 = Theorem;
                        Theorem_0000[LHS] = Theorem_0000[LHS] / Axiom[LHS] * Axiom[RHS];
                        std::cout << "Theorem_0000 {" << Theorem_0000[LHS] << ", " << Theorem_0000[RHS] << "}" << std::endl;
                        
                        Tasks_Thread[Write].emplace_back(Theorem_0000);
                    }
                    
                    if (
                        Theorem[LHS] % Axiom[RHS] == 0 &&
                        CallHistory[ Theorem[LHS] ][ Axiom[RHS] ] == 
                        false)
                    {
                        CallHistory[ Theorem[LHS] ][ Axiom[RHS] ] = true;
                        
                        std::array<uint64_t, 2> Theorem_0000 = Theorem;
                        Theorem_0000[LHS] = Theorem_0000[LHS] / Axiom[RHS] * Axiom[LHS];
                        std::cout << "Theorem_0000 {" << Theorem_0000[LHS] << ", " << Theorem_0000[RHS] << "}" << std::endl;
                        
                        Tasks_Thread[Write].emplace_back(Theorem_0000);
                    }
                    
                    if (
                        Theorem[RHS] % Axiom[LHS] == 0 &&
                        CallHistory[ Theorem[RHS] ][ Axiom[LHS] ] == 
                        false)
                    {
                        CallHistory[ Theorem[RHS] ][ Axiom[LHS] ] = true;
                        
                        std::array<uint64_t, 2> Theorem_0000 = Theorem;
                        Theorem_0000[RHS] = Theorem_0000[RHS] / Axiom[LHS] * Axiom[RHS];
                        std::cout << "Theorem_0000 {" << Theorem_0000[LHS] << ", " << Theorem_0000[RHS] << "}" << std::endl;
                        
                        Tasks_Thread[Write].emplace_back(Theorem_0000);
                    }
                    
                    if (Theorem[RHS] % Axiom[RHS] == 0 &&
                        CallHistory[ Theorem[RHS] ][ Axiom[RHS] ] == 
                        false)
                    {
                        CallHistory[ Theorem[RHS] ][ Axiom[RHS] ] = true;
                        
                        std::array<uint64_t, 2> Theorem_0000 = Theorem;
                        Theorem_0000[RHS] = Theorem_0000[RHS] / Axiom[RHS] * Axiom[LHS];
                        std::cout << "Theorem_0000 {" << Theorem_0000[LHS] << ", " << Theorem_0000[RHS] << "}" << std::endl;
                        
                        Tasks_Thread[Write].emplace_back(Theorem_0000);
                    }
                } // end test (QED)
            } // end for (...Axiom : Axioms_UInt64Vec)
            
            if (QED)
            {
                break;
            } 
        } // end for (...Theorem : Tasks_Thread[Read])
    
        Tasks_Thread[Read] = {};
        
        Write = Round.NextRound_UInt8 ();
        Read = Round.CurrentRound_UInt8 ();
    } // end while (Tasks_Thread[Read].size() && !QED)
    
    if (!QED)
    {   
        std::cout << "No Proof Found." << std::endl;
    }

    const auto end_time_chrono = std::chrono::high_resolution_clock::now();
    const auto duration_chrono = std::chrono::duration_cast<std::chrono::nanoseconds>(end_time_chrono - start_time_chrono).count();
    std::cout << "Total Duration (nanoseconds): " << duration_chrono << std::endl;

    return EXIT_SUCCESS;
}
//
struct AxiomProto_Struct
{
    AxiomProto_Struct()
    {
        
    };
    
    AxiomProto_Struct(AxiomProto_Struct& other)
    {
        LHSPrimaryKey_UInt64 = other.LHSPrimaryKey_UInt64;
        RHSPrimaryKey_UInt64 = other.RHSPrimaryKey_UInt64;
        
        LHS_StdStrVec = other.LHS_StdStrVec;
        RHS_StdStrVec = other.RHS_StdStrVec;
        
        LHSCallHistory = other.LHSCallHistory;
        RHSCallHistory = other.RHSCallHistory;
        
        CallHistory = other.CallHistory;
        
        LHSCallGraph_UInt64Map = other.LHSCallGraph_UInt64Map;
        RHSCallGraph_UInt64Map = other.RHSCallGraph_UInt64Map;

        bParseStrict_Flag = other.bParseStrict_Flag;
    
        guid = other.guid;
    };
    
    uint64_t LHSPrimaryKey_UInt64 {};
    uint64_t RHSPrimaryKey_UInt64 {};

    std::vector<std::string> LHS_StdStrVec {};
    std::vector<std::string> RHS_StdStrVec {};

    std::unordered_map<RouteGoal_EnumClass,
        std::unordered_map<uint64_t, bool>>
        LHSCallHistory {};

    std::unordered_map<RouteGoal_EnumClass,
        std::unordered_map<uint64_t, bool>>
        RHSCallHistory {};

    std::unordered_map<uint64_t, bool>
        CallHistory {};

    std::unordered_map<RouteGoal_EnumClass,
        std::unordered_map<uint64_t, bool>>
        LHSCallGraph_UInt64Map {};

    std::unordered_map<RouteGoal_EnumClass,
        std::unordered_map<uint64_t, bool>>
        RHSCallGraph_UInt64Map {};

    bool SubnetFound_LHS(const uint64_t& PKeyFind) const noexcept
    {
        const bool ret = (LHSPrimaryKey_UInt64 % PKeyFind) == 0;
        return ret;
    }

    bool SubnetFound_RHS(const uint64_t& PKeyFind) const noexcept
    {
        const bool ret = (RHSPrimaryKey_UInt64 % PKeyFind) == 0;
        return ret;
    }

    bool bParseStrict_Flag {};

    uint64_t guid {};
};
//
    //Theorem.Indir_EnumClass = Indirection_EnumClass::_auto; // _reduce; // _expand;

    auto _0000 = Theorem.LHSCallGraph_UInt64Map.find(RouteGoal_EnumClass::_lhs);
    if (_0000 != Theorem.LHSCallGraph_UInt64Map.end())
    {
        std::cout << "Theorem.LHSCallGraph_UInt64Map[RouteGoal_EnumClass::_lhs] = {";
        bool NextCall_Flag{};
        for (const auto& [idx_UInt64, boolType] : _0000->second)
        {
            if (NextCall_Flag)
            {
                std::cout << ", ";
                NextCall_Flag = false;
            }
            std::cout << idx_UInt64 << "";
            NextCall_Flag = true;
        }
        std::cout << "}" << std::endl;
    }
    _0000 = Theorem.LHSCallGraph_UInt64Map.find(RouteGoal_EnumClass::_rhs);
    if (_0000 != Theorem.LHSCallGraph_UInt64Map.end())
    {
        std::cout << "Theorem.LHSCallGraph_UInt64Map[RouteGoal_EnumClass::_rhs] = {";
        bool NextCall_Flag{};
        for (const auto& [idx_UInt64, boolType] : _0000->second)
        {
            if (NextCall_Flag)
            {
                std::cout << ", ";
                NextCall_Flag = false;
            }
            std::cout << idx_UInt64 << "";
            NextCall_Flag = true;
        }
        std::cout << "}" << std::endl;
    }
    _0000 = Theorem.RHSCallGraph_UInt64Map.find(RouteGoal_EnumClass::_lhs);
    if (_0000 != Theorem.RHSCallGraph_UInt64Map.end())
    {
        std::cout << "Theorem.RHSCallGraph_UInt64Map[RouteGoal_EnumClass::_lhs] = {";
        bool NextCall_Flag{};
        for (const auto& [idx_UInt64, boolType] : _0000->second)
        {
            if (NextCall_Flag)
            {
                std::cout << ", ";
                NextCall_Flag = false;
            }
            std::cout << idx_UInt64 << "";
            NextCall_Flag = true;
        }
        std::cout << "}" << std::endl;
    }
    _0000 = Theorem.RHSCallGraph_UInt64Map.find(RouteGoal_EnumClass::_rhs);
    if (_0000 != Theorem.RHSCallGraph_UInt64Map.end())
    {
        std::cout << "Theorem.RHSCallGraph_UInt64Map[RouteGoal_EnumClass::_rhs] = {";
        bool NextCall_Flag{};
        for (const auto& [idx_UInt64, boolType] : _0000->second)
        {
            if (NextCall_Flag)
            {
                std::cout << ", ";
                NextCall_Flag = false;
            }
            std::cout << idx_UInt64 << "";
            NextCall_Flag = true;
        }
        std::cout << "}" << std::endl;
    }

    //std::cout << Tasks_Thread[0][0].guid << std::endl;
//
            if (idx_UInt64 == InTheorem.guid)
            {
                // guid are the same //
                std::cout << "processTheorem: Exiting callHistory_0000[]... guids are the same." << std::endl;
                continue;
            }
//
    Axiom_Struct():
        AxiomProto_Struct()
    {
      
    };

    Axiom_Struct(const Axiom_Struct& other) :
        AxiomProto_Struct(other)
    {
        
    };
    
    Axiom_Struct(Axiom_Struct&& other) noexcept :
        AxiomProto_Struct(std::move(other))
    {
        
    };
    
    Axiom_Struct& operator=(Axiom_Struct&& other) noexcept
    {
        if (this != &other) {
            AxiomProto_Struct::operator=(std::move(other));
        }
        return *this;
    }
    
    Axiom_Struct& operator=(const Axiom_Struct& other)
    {
        if (this != &other) {
            AxiomProto_Struct::operator=(other);
        }
        return *this;
    };
//
    Theorem_Struct() :
        AxiomProto_Struct()
    {
        
    };
        
    Theorem_Struct(const Theorem_Struct& other) :
        AxiomProto_Struct(other),
        TotalProofsFound_UInt64(other.TotalProofsFound_UInt64),
        MaxAllowedProofs_UInt64(other.MaxAllowedProofs_UInt64),
        ProofFound_Flag(other.ProofFound_Flag),
        ProofStack_VecUInt64(other.ProofStack_VecUInt64),
        ProofString_StdStrVec(other.ProofString_StdStrVec),
        Indir_EnumClass(other.Indir_EnumClass)
    {
    };
    
    Theorem_Struct(Theorem_Struct&& other) noexcept :
        AxiomProto_Struct(std::move(other)),
        TotalProofsFound_UInt64(std::move(other.TotalProofsFound_UInt64)),
        MaxAllowedProofs_UInt64(std::move(other.MaxAllowedProofs_UInt64)),
        ProofFound_Flag(std::move(other.ProofFound_Flag)),
        ProofStack_VecUInt64(std::move(other.ProofStack_VecUInt64)),
        ProofString_StdStrVec(std::move(other.ProofString_StdStrVec)),
        Indir_EnumClass(std::move(other.Indir_EnumClass))
    {
        other.TotalProofsFound_UInt64 = 0;
        other.MaxAllowedProofs_UInt64 = 0;
        other.ProofFound_Flag = false;
        other.ProofStack_VecUInt64.clear();
        other.ProofString_StdStrVec.clear();
        other.Indir_EnumClass = Indirection_EnumClass::_auto;
    };
    
    Theorem_Struct& operator= (Theorem_Struct&& other) noexcept
    {
        if (this != &other) {
            AxiomProto_Struct::operator=(std::move(other));
            TotalProofsFound_UInt64 = std::move(other.TotalProofsFound_UInt64);
            MaxAllowedProofs_UInt64 = std::move(other.MaxAllowedProofs_UInt64);
            ProofFound_Flag = std::move(other.ProofFound_Flag);
            ProofStack_VecUInt64 = std::move(other.ProofStack_VecUInt64);
            ProofString_StdStrVec = std::move(other.ProofString_StdStrVec);
            Indir_EnumClass = std::move(other.Indir_EnumClass);
            
            other.TotalProofsFound_UInt64 = 0;
            other.MaxAllowedProofs_UInt64 = 0;
            other.ProofFound_Flag = false;
            other.ProofStack_VecUInt64.clear();
            other.ProofString_StdStrVec.clear();
            other.Indir_EnumClass = Indirection_EnumClass::_auto;
        }
        return *this;
    };
    
    Theorem_Struct& operator= (const Theorem_Struct& other)
    {
        if (this != &other) {
        AxiomProto_Struct::operator=(other);
        TotalProofsFound_UInt64 = other.TotalProofsFound_UInt64;
        MaxAllowedProofs_UInt64 = other.MaxAllowedProofs_UInt64;
        ProofFound_Flag = other.ProofFound_Flag;
        ProofStack_VecUInt64 = other.ProofStack_VecUInt64;
        ProofString_StdStrVec = other.ProofString_StdStrVec;
        Indir_EnumClass = other.Indir_EnumClass;
        }
        return *this;
    };
//
    Axiom_Struct():
        AxiomProto_Struct()
    {
      
    };

    Axiom_Struct(const Axiom_Struct& other) :
        AxiomProto_Struct(other)
    {
    };
//
    Theorem_Struct() :
        AxiomProto_Struct()
    {
        
    };
        
    Theorem_Struct(const Theorem_Struct& other) :
        AxiomProto_Struct(other),
        TotalProofsFound_UInt64(other.TotalProofsFound_UInt64),
        MaxAllowedProofs_UInt64(other.MaxAllowedProofs_UInt64),
        ProofFound_Flag(other.ProofFound_Flag),
        ProofStack_VecUInt64(other.ProofStack_VecUInt64),
        ProofString_StdStrVec(other.ProofString_StdStrVec),
        Indir_EnumClass(other.Indir_EnumClass)
    {
    };

    
//
    AxiomProto_Struct()
    {
        LHSCallHistory[RouteGoal_EnumClass::_lhs] = {};
        LHSCallHistory[RouteGoal_EnumClass::_rhs] = {};
        
        RHSCallHistory[RouteGoal_EnumClass::_lhs] = {};
        RHSCallHistory[RouteGoal_EnumClass::_rhs] = {};
        
        
        LHSCallGraph_UInt64Map[RouteGoal_EnumClass::_lhs] = {};
        LHSCallGraph_UInt64Map[RouteGoal_EnumClass::_rhs] = {};
            
        RHSCallGraph_UInt64Map[RouteGoal_EnumClass::_lhs] = {};
        RHSCallGraph_UInt64Map[RouteGoal_EnumClass::_rhs] = {};
    };
    
//
    Tasks_Thread[0].push_back(Theorem);
    
    auto _0000 = Theorem.LHSCallGraph_UInt64Map.find(RouteGoal_EnumClass::_lhs);
    if(_0000 != Theorem.LHSCallGraph_UInt64Map.end())
    {
        std::cout << "Theorem.LHSCallGraph_UInt64Map[RouteGoal_EnumClass::_lhs] = {";
        bool NextCall_Flag {};
        for (const auto& [idx_UInt64, boolType] : _0000->second)
        {   if (NextCall_Flag)
            {
                std::cout << ", ";
                NextCall_Flag = false;
            }
            std::cout << idx_UInt64 << "";
            NextCall_Flag = true;
        }
        std::cout << "}" << std::endl;
    }
    _0000 = Theorem.LHSCallGraph_UInt64Map.find(RouteGoal_EnumClass::_rhs);
    if(_0000 != Theorem.LHSCallGraph_UInt64Map.end())
    {
        std::cout << "Theorem.LHSCallGraph_UInt64Map[RouteGoal_EnumClass::_rhs] = {";
        bool NextCall_Flag {};
        for (const auto& [idx_UInt64, boolType] : _0000->second)
        {   if (NextCall_Flag)
            {
                std::cout << ", ";
                NextCall_Flag = false;
            }
            std::cout << idx_UInt64 << "";
            NextCall_Flag = true;
        }
        std::cout << "}" << std::endl;
    }
    _0000 = Theorem.RHSCallGraph_UInt64Map.find(RouteGoal_EnumClass::_lhs);
    if(_0000 != Theorem.RHSCallGraph_UInt64Map.end())
    {
        std::cout << "Theorem.RHSCallGraph_UInt64Map[RouteGoal_EnumClass::_lhs] = {";
        bool NextCall_Flag {};
        for (const auto& [idx_UInt64, boolType] : _0000->second)
        {   if (NextCall_Flag)
            {
                std::cout << ", ";
                NextCall_Flag = false;
            }
            std::cout << idx_UInt64 << "";
            NextCall_Flag = true;
        }
        std::cout << "}" << std::endl;
    }
    _0000 = Theorem.RHSCallGraph_UInt64Map.find(RouteGoal_EnumClass::_rhs);
    if(_0000 != Theorem.RHSCallGraph_UInt64Map.end())
    {
        std::cout << "Theorem.RHSCallGraph_UInt64Map[RouteGoal_EnumClass::_rhs] = {";
        bool NextCall_Flag {};
        for (const auto& [idx_UInt64, boolType] : _0000->second)
        {   if (NextCall_Flag)
            {
                std::cout << ", ";
                NextCall_Flag = false;
            }
            std::cout << idx_UInt64 << "";
            NextCall_Flag = true;
        }
        std::cout << "}" << std::endl;
    }

//
                    else 
                    {
                        std::cout << "Error: Improperly initialized Theorem at in index Tasks_Thread[N]." << std::endl;
                        continue;
                    }
//
            /*
            There are atleast 16 permutations of these, 
            such as (LHSCallGraph && !find(RouteGoal::_lhs)), 
            (LHSCallGraph && !find(RouteGoal::_rhs)), ... etc.
            Only include those which are useful.
            */
//
    //std::vector<Theorem_Struct> InOut;
    
    /*
    int i = 3;
    
    while(i)
    {
        std::cout << static_cast<unsigned int>(Round.NextRound_UInt8()) << std::endl;
        --i;
    }
    */
// local scope: Get the current stack size limit
{ 
	struct rlimit stack_limit;
	if (getrlimit(RLIMIT_STACK, &stack_limit) == 0)
	{
		RecursionLimiter::set_recursion_limit(stack_limit.rlim_cur); 
	}
}
//
#include <vector>
#include <chrono>
#include <iostream>
#include <thread>
#include <variant>
#include <unordered_map>
#include <functional>
#include <execution>
#include <stop_token>
#include <thread>
#include <future>
#include <mutex>
#include <algorithm>
#include <cstdint>

/*

  AUTHOR
      Seagat2011 www.gitub.com/Seagat2011
      eterna.cmu.edu/web/player/90270/
      fold.it/port/user/1992490

  VERSION
      Major.Minor.Bugfix.Patch
      11.0.0.0

  DESCRIPTION
    Theorem prover written in C++20 ported from JavaScript (An E-normalization to normal form, term-rewriting system)
    for use in the Unreal Engine 5.2 Core Lib

  UPDATED
    +Negative proof assertions ~=
    +_AXIOM_.optimizeCallGraph
    +Improved ProofComplete search performance
    +Prove via Auto (PASS)
    +Axiom._eval => Axiom._reduce
    +Axiom.{_reduce,_expand} => eventListener(s)
    +solutionEditor => contentEditable
    +Prove via Reduce (PASS)
    +Prove via Expand (PASS)
    +scoping functionality
    +LibreOffice math library support
    -Axiom._eval eventListener

  NOTES:
    Term rewrites are performed with the aid of a compiler (ie. via LEMMA SUBSTITUTION); SEE TEST CASES

    Substitution methods:
    1. (direct) AXIOMATIC: 1 + 1 = 2
    2. (indirect) LEMMA SUBSTITUTION: 1 <==> 1/1
    Warning: Lemma substitutions rewrite axioms -- which can introduce recursion, stack overflow, and other bugs.

  Usage Example. // Lemma substitution //

    { { a } raised { 2 } } plus { 2ab } plus { b raised { 2 } } <== ( { a } plus { b } ) raised { 2 }
    ( { a } plus { b } ) raised { 2 } minus { 2ab } = { c } raised { 2 } <== ( { a } plus { b } ) raised { 2 } = { { c } raised { 2 } } plus { 2ab }
    { { a } raised { 2 } } plus { 2ab } minus { 2ab } plus { b raised { 2 } } ==> { { a } raised { 2 } } plus { { b } raised { 2 } }
    ( { a } plus { b } ) raised { 2 } = { { c } raised { 2 } } plus { 2ab }
    Prove { { a } raised { 2 } } plus { { b } raised { 2 } } = { c } raised { 2 }

  Usage Example. // Lemma substitution //
    
	// Axiom
	{ PlayerCharacterSideKick } IsIn { StyxBoat } = { StyxBoat } IsIn { StyxRiver } // Current Game State
	{ PlayerCharacterSideKick } IsIn { Vehicle { QuadUtilityVehicle } } = { Vehicle { QuadUtilityVehicle } } IsIn { EuropaLand } and { Vehicle { QuadUtilityVehicle { VehicleDriveDisabled } } }
	{ PlayerCharacterSideKick } IsIn { EuropaLand } = { Vehicle { QuadUtilityVehicle } } IsIn { EuropaLand }
	{ PlayerCharacterSideKick } IsIn { QuadUtilityVehicle } = { Vehicle { QuadUtilityVehicle { VehicleDriveDisabled } } }
	{ PlayerCharacterSideKick } IsNotIn { Vehicle { QuadUtilityVehicle } } = { Vehicle { QuadUtilityVehicle } } IsIn { EuropaLand }
	.
	. [Other available non-relevant Game States, in the current environment, for the PlayerCharacterSideKick to choose from ]
	.
	{ PlayerCharacterSideKick } IsIn { QuadUtilityVehicle } = { QuadUtilityVehicle } and { VehicleDriveDisabled } 

	// Lemma
	{ PlayerCharacterSideKick } IsIn { StyxBoat } <== { StyxBoat } IsNotIn { StyxRiver } // These are connectives, and axiom helpers
	{ PlayerCharacterSideKick } IsOn { Vehicle } <== { VehicleDriveDisabled }
	{ PlayerCharacterSideKick } IsIn { Vehicle { QuadUtilityVehicle } } <== { PlayerCharacterSideKick } IsIn { QuadUtilityVehicle }
	{ PlayerCharacterSideKick } IsNotIn { StyxBoat } ==> { StyxBoat } IsNotIn { StyxRiver }

	// Theorem
	Prove { PlayerCharacterSideKick } IsIn { QuadUtilityVehicle } = { QuadUtilityVehicle } and { VehicleDriveDisabled }

	// Output (Proof-Steps)
	{ PlayerCharacterSideKick } IsIn { StyxBoat } = { StyxBoat } IsIn { StyxRiver }
	{ PlayerCharacterSideKick } IsIn { StyxBoat } = { StyxBoat } IsNotIn { StyxRiver }
	{ PlayerCharacterSideKick } IsNotIn { StyxBoat } = { StyxBoat } IsNotIn { StyxRiver }
	{ PlayerCharacterSideKick } IsIn { EuropaLand } = { Vehicle { QuadUtilityVehicle } } IsIn { EuropaLand }
	{ PlayerCharacterSideKick } IsNotIn { Vehicle { QuadUtilityVehicle } } = { Vehicle { QuadUtilityVehicle } } IsIn { EuropaLand }
	{ PlayerCharacterSideKick } IsIn { Vehicle { QuadUtilityVehicle } } = { Vehicle { QuadUtilityVehicle } } IsIn { EuropaLand } and { Vehicle { QuadUtilityVehicle { VehicleDriveDisabled } } }
	{ PlayerCharacterSideKick } IsIn { QuadUtilityVehicle } = { Vehicle { QuadUtilityVehicle { VehicleDriveDisabled } } }
	{ PlayerCharacterSideKick } IsIn { QuadUtilityVehicle } = { QuadUtilityVehicle } and { VehicleDriveDisabled } 

  REFERENCES

  COMPATIBILITY
    Windows 11+ x86i64

*/ 

enum class RouteSource_EnumClass : int
{
	_lhs,
	_rhs
};

enum class Indirection_EnumClass : int
{
	_auto,
	_reduce,
	_expand
};

struct AxiomProto_Struct
{
	uint64_t LHSPrimaryKey_UInt64{};
	uint64_t RHSPrimaryKey_UInt64{};

	std::vector<std::string> LHS_StdStrVec;
	std::vector<std::string> RHS_StdStrVec;

	std::unordered_map<uint64_t, bool> LHSCallHistory;
	std::unordered_map<uint64_t, bool> RHSCallHistory;

	std::unordered_map<RouteSource_EnumClass,
		std::unordered_map<uint64_t, bool>>
		LHSCallGraph_UInt64Map;

	std::unordered_map<RouteSource_EnumClass,
		std::unordered_map<uint64_t, bool>>
		RHSCallGraph_UInt64Map;

	bool SubnetFound_LHS(const uint64_t& PKeyFind) const noexcept
	{
		const bool ret = (LHSPrimaryKey_UInt64 % PKeyFind) == 0;
		return ret;
	}

	bool SubnetFound_RHS(const uint16_t& PKeyFind) const noexcept
	{
		const bool ret = (RHSPrimaryKey_UInt64 % PKeyFind) == 0;
		return ret;
	}

	bool bParseStrict_Flag{};

	uint64_t guid{};
};

struct Theorem_Struct : public AxiomProto_Struct
{
	uint64_t TotalProofsFound_UInt64{};
	uint64_t MaxAllowedProofs_UInt64 = 1;

	bool ProofFound_Flag{};

	std::vector<uint64_t> ProofStack_VecUInt64;

	std::vector<std::string> ProofString_StdStrVec;

	Indirection_EnumClass Indir_EnumClass = Indirection_EnumClass::_auto;

	bool UpdatePrimaryKey_LHS(const uint64_t& PKeyFind, const uint64_t& PKeyReplace) noexcept
	{
		bool ReturnStatus_Flag{};
		LHSPrimaryKey_UInt64 = LHSPrimaryKey_UInt64 / PKeyFind * PKeyReplace;
		ReturnStatus_Flag = true;
		return ReturnStatus_Flag;
	}

	bool UpdatePrimaryKey_RHS(const uint64_t& PKeyFind, const uint64_t& PKeyReplace) noexcept
	{
		bool ReturnStatus_Flag{};
		RHSPrimaryKey_UInt64 = RHSPrimaryKey_UInt64 / PKeyFind * PKeyReplace;
		ReturnStatus_Flag = true;
		return ReturnStatus_Flag;
	}
};

struct Axiom_Struct : public AxiomProto_Struct
{

};

std::ostream& operator<< (std::ostream& os, const RouteSource_EnumClass& route)
{
	switch (route)
	{
		case RouteSource_EnumClass::_lhs:
			os << "RouteSource_EnumClass::_lhs";
			break;
		case RouteSource_EnumClass::_rhs:
			os << "RouteSource_EnumClass::_rhs";
			break;
		default:
			os.setstate(std::ios_base::failbit);
	}
	return os;
};

int main()
{
	const auto start_time_chrono = std::chrono::high_resolution_clock::now();

	/*
	token: [ "1" "2" "4" "+" ]
	prime: [  2   3   5   7 ]
	*/

	std::vector<std::array<uint64_t,2>> Axioms_UInt64Vec = // const (global) task list
	{
		{//std::vector<uint64_t> _1p1p1p1e4 =
			5488, // "1 + 1 + 1 + 1"
			5 // "4"
		},//;

		{//std::vector<uint64_t> _1p1e2 =
			28, // "1 + 1"
			3 // "2"
		},//;

		{//std::vector<uint64_t> _2p2e4 =
			63, // "2 + 2"
			5 // "4"
		}
	};

	using Map = std::unordered_map<uint64_t, std::unordered_map<uint64_t, bool>>;
	Map LHSCallGraph_UInt64Map;
	Map RHSCallGraph_UInt64Map;

	uint64_t GUID = 0;

    std::array<Axiom_Struct,2> Axioms_Vec;
    
	Theorem_Struct Theorem;

	// Compile
	auto processAxioms = [&GUID,&Axioms_UInt64Vec,&Theorem,&Axioms_Vec]() noexcept -> void
	{
		for (const std::array<uint64_t,2>& Axiom_i : Axioms_UInt64Vec)
		{
			uint64_t  lhs = Axiom_i[0];
			uint64_t  rhs = Axiom_i[1];

			const uint64_t _lhs = Axiom_i[0];
			const uint64_t _rhs = Axiom_i[1];

			if (_lhs < _rhs)
			{
				lhs = _rhs;
				rhs = _lhs;
			}
			
			if(GUID < 1)
            {
            	Theorem.guid = GUID++;
            	Theorem.LHSPrimaryKey_UInt64 = lhs;
            	Theorem.RHSPrimaryKey_UInt64 = rhs;
            	continue;
            }
            
			Axiom_Struct Axiom;
			Axiom.guid = GUID++;
			Axiom.LHSPrimaryKey_UInt64 = lhs;
			Axiom.RHSPrimaryKey_UInt64 = rhs;
			
			/*
			Authorize qualifying subnets by adding
			their netlist to the outbound route map
			*/
			
			if (Theorem.SubnetFound_LHS(lhs))
			{
				Axiom.RHSCallGraph_UInt64Map[RouteSource_EnumClass::_lhs][Theorem.guid] = true;
			}

			if (Theorem.SubnetFound_RHS(lhs))
			{
				Axiom.RHSCallGraph_UInt64Map[RouteSource_EnumClass::_rhs][Theorem.guid] = true;
			}

			if (Theorem.SubnetFound_LHS(rhs))
			{
				Axiom.LHSCallGraph_UInt64Map[RouteSource_EnumClass::_lhs][Theorem.guid] = true;
			}

			if (Theorem.SubnetFound_RHS(rhs))
			{
				Axiom.LHSCallGraph_UInt64Map[RouteSource_EnumClass::_rhs][Theorem.guid] = true;
			}

			Axioms_Vec[Axiom.guid - 1] = Axiom;
		}
		/*
		for (const Axiom_Struct& Axiom_i : Axioms_Vec)
		{
            std::cout << Axiom_i.guid << std::endl;
		}
		*/
		for (const Axiom_Struct& Axiom_i : Axioms_Vec)
		{
			for (Axiom_Struct& Axiom_j : Axioms_Vec)
			{
				const bool ijAvoidsACallLoop_Flag = (Axiom_i.guid != Axiom_j.guid); // Avoid Call loops
				/*
				Authorize qualifying subnets by adding
				their netlist to the outbound route map
				*/
				if (ijAvoidsACallLoop_Flag)
				{
				    /*
				    std::cout 
				    << "Axiom_" << Axiom_i.guid << ":{ lhs:" << Axiom_i.LHSPrimaryKey_UInt64 << ", rhs:" << Axiom_i.RHSPrimaryKey_UInt64 << " }; "
				    << "Axiom_" << Axiom_j.guid << ":{ lhs:" << Axiom_j.LHSPrimaryKey_UInt64 << ", rhs:" << Axiom_j.RHSPrimaryKey_UInt64 << " }; " 
				    << std::endl;
				    */
					if (Axiom_i.SubnetFound_LHS(Axiom_j.LHSPrimaryKey_UInt64))
					{
						Axiom_j.RHSCallGraph_UInt64Map[RouteSource_EnumClass::_lhs][Axiom_i.guid] = true;
					}

					if (Axiom_i.SubnetFound_LHS(Axiom_j.RHSPrimaryKey_UInt64))
					{
						Axiom_j.LHSCallGraph_UInt64Map[RouteSource_EnumClass::_lhs][Axiom_i.guid] = true;
					}

					if (Axiom_i.SubnetFound_RHS(Axiom_j.LHSPrimaryKey_UInt64))
					{
						Axiom_j.RHSCallGraph_UInt64Map[RouteSource_EnumClass::_rhs][Axiom_i.guid] = true;
					}

					if (Axiom_i.SubnetFound_RHS(Axiom_j.RHSPrimaryKey_UInt64))
					{
						Axiom_j.LHSCallGraph_UInt64Map[RouteSource_EnumClass::_rhs][Axiom_i.guid] = true;
					}
				}
			}
		}
	};
	
	std::jthread th(processAxioms);
	th.join();

	const auto end_time_chrono = std::chrono::high_resolution_clock::now();
	const auto duration_chrono = std::chrono::duration_cast<std::chrono::nanoseconds>(end_time_chrono - start_time_chrono).count();
	std::cout << "Total Duration (nanoseconds): " << duration_chrono << std::endl;
    /*
	// Iterate and print the contents of the map
	for (const Axiom_Struct& Axiom : Axioms_Vec)
	{
		for (const auto& outer_pair : Axiom.LHSCallGraph_UInt64Map) {
			const RouteSource_EnumClass& outer_key = outer_pair.first;
			const std::unordered_map<uint64_t, bool>& inner_map = outer_pair.second;

			for (const auto& inner_pair : inner_map) {
				const uint64_t inner_key = inner_pair.first;
				const bool value = inner_pair.second;

				std::cout << "Axiom_" << Axiom.guid << ".LHSCallGraph_UInt64Map[" << outer_key << "][" << inner_key << "] = " << std::boolalpha << value << '\n';
			}
		}
	}
    */
	return 0;
}

