

void RemoveEmptyStrings(auto& vec)
{
    // Remove empty strings from-, and resize-, the vec.
    vec.erase(
        std::remove_if(
            vec.begin(), 
            vec.end(), 
            [](const std::string& s)
            {
                return s.empty();
            }), vec.end());
}
//
bool TentativeProofVerified
(
    const
    std::vector<
    std::string>&
    Theorem, 
    
    const
    std::vector<
    std::vector<
    std::string>>&
    InTheorem_StdStrVec, 
    
    const
    std::vector<
    std::vector<
    std::vector<
    std::string>>>&
    InAxioms_StdStrVec,
    
    std::vector<
    std::vector<
    std::string>>&
    OutAxiomCommitLog_StdStrVecRef
)
{
  // Clone InTheorem_StdStrVec as OutTheorem_StdStrVec. //
  std::vector<
  std::vector<
  std::vector<
  std::string>>>
  OutTheorem_StdStrVec {InTheorem_StdStrVec};
  
  std::vector<
  std::vector<
  std::string>>
  TempTheorem_StdStrVec {InTheorem_StdStrVec};

  /**
    Loop through Theorem, starting at Theorem[ProofStack_UInt64],
    and read two values from the vector at a time: Theorem[ProofStack_UInt64 + i++],
    Theorem[ProofStack_UInt64 + i++] - 1.
  
    The first value read out, const auto& opcode = Theorem[ProofStack_UInt64 + i++],
    is an opcode whose hexadecimal value may range from 0x00 to 0x03.
  
    The second value read out, const auto& guid = Theorem[ProofStack_UInt64 + i++] - 1,
    is an index into InAxioms_StdStrVec.
  */
  
  uint64_t i {ProofStack_UInt64};
  while (i < Theorem.size()) {
    const auto& opcode = Theorem[i++];
    const auto& guid = Theorem[i++] - 1;

    switch (opcode)
    {
        case 0x00: { // "lhs_reduce" operation
            if (TempTheorem_StdStrVec[LHS].size() < InAxioms_StdStrVec[guid][LHS].size())
                return false;
            uint64_t k {};
            for (uint64_t j = 0; j < TempTheorem_StdStrVec[LHS].size(); j++) {
                if (TempTheorem_StdStrVec[LHS][j] == InAxioms_StdStrVec[guid][LHS][k]) {
                    TempTheorem_StdStrVec[LHS][j] = InAxioms_StdStrVec[guid][RHS][k++];
                }
            }
            TempAxiomCommitLog_StdStrVecRef.emplace_back("lhs_reduce via Axiom_" + guid/*.str()*/ );
            break;
        }
        case 0x01: { // "lhs_expand" operation
          if (TempTheorem_StdStrVec[LHS].size() < InAxioms_StdStrVec[guid][RHS].size())
            return false;
            uint64_t k {};
          for (uint64_t j = 0; j < TempTheorem_StdStrVec[RHS].size(); j++) {
            if (TempTheorem_StdStrVec[RHS][j] == InAxioms_StdStrVec[guid][LHS][k]) {
              TempTheorem_StdStrVec[RHS][j] = InAxioms_StdStrVec[guid][RHS][k++];
            }
          }
          break;
        }
        case 0x02: { // "rhs_reduce" operation
          if (TempTheorem_StdStrVec[RHS].size() < InAxioms_StdStrVec[guid][LHS].size())
            return false;
            uint64_t k {};
          for (uint64_t j = 0; j < TempTheorem_StdStrVec[LHS].size(); j++) {
            if (TempTheorem_StdStrVec[LHS][j] == InAxioms_StdStrVec[guid][RHS][k]) {
              TempTheorem_StdStrVec[LHS][j] = InAxioms_StdStrVec[guid][LHS][k++];
            }
          }
          break;
        }
        case 0x03: { // "rhs_expand" operation
          if (TempTheorem_StdStrVec[RHS].size() < InAxioms_StdStrVec[guid][RHS].size())
            return false;
            uint64_t k {};
          for (uint64_t j = 0; j < TempTheorem_StdStrVec[RHS].size(); j++) {
            if (TempTheorem_StdStrVec[RHS][j] == InAxioms_StdStrVec[guid][RHS][k]) {
              TempTheorem_StdStrVec[RHS][j] = InAxioms_StdStrVec[guid][LHS][k++];
            }
          }
          break;
        }
        default: {
          // Invalid opcode.
          return false;
        }
    } // end switch(opcode)
    OutAxiomCommitLog_StdStrVecRef.emplace_back(TempAxiomCommitLog_StdStrVecRef);
    OutTheorem_StdStrVec.emplace_back(TempTheorem_StdStrVec);
  }

  // If TentativeProofVerified is unable to complete the loop, the algorithm returns false.
  return true;
}
//
bool PeekScopeSatisfied
(
    auto& th,
    
    auto& th_idx, 
    
    const auto& from
)
{
    uint64_t j {};
    const uint64_t I = th.size();
    const uint64_t J = from.size();
    
    for (uint64_t i = th_idx; i < I; ++i)
    {
        if (th[i] == from[j])
        {
            th[i] = "";
            ++j;
            /*
            if (j < J)
            {
                //continue;
            } else {
                break;
            }
            */
        } else {
            break;
        }
    }
    
    return (j == J);
}

bool Rewrite
(
    auto& th, 
    
    const auto& from, 
    
    const auto& to
)
{
    bool bSuccessFlag {};
    
    if (th.size() < from.size())
        return false;
        
    std::unordered_map<std::string, std::string>
    
    end_scope {{"(", ")"}, {"{", "}"}, {"[", "]"}};
    
    std::vector<
    std::string> result {};
        
    uint64_t i {};
    
    for (const auto& val : th )
    {
        auto tmp {result};
        uint64_t k {i};
        
        if (
            val == from[0] /*&& 
            PeekScopeSatisfied
            (tmp, k, from)*/
            ) // &tmp, &k //
        {
            /*
            i = k;
        
            uint64_t j {};
            
            for (const auto& u : tmp)
            {
                if(j < i)
                {
                    result.emplace_back(u);
                } else if (j == i) {
                    for (const auto& u2 : to)
                    {
                        result.emplace_back (u2);
                    }
                }
                ++j;
            }
            */
            result = tmp;
            bSuccessFlag = true;
            std::cout << "Match found";
        } else {
            std::cout << "No Match found" << val << std::endl;
            result.emplace_back (val);
        }
        ++i;
    }
    
    //RemoveEmptyStrings(result);
    
    th = result;
    
    return bSuccessFlag;
}

//
bool _scope_satisfied
(
    const
    std::string&
    etok_lhs,
    
    const
    std::vector<
    std::string>&
    lhs,
    
    const
    uint64_t&
    lhs_idx,
    
    const
    std::vector<
    std::string>&
    rhs,
    
    const
    uint64_t&
    rhs_idx
)
{
    uint64_t i = 1;
    std::unordered_map<std::string, std::string> end_scope{{"(", ")"}, {"{", "}"}, {"[", "]"}};
    bool sat = true;
    if (lhs[lhs_idx] != rhs[rhs_idx]) {
        sat = false;
    } else if (end_scope.find(etok_lhs) != end_scope.end()) {
        if (
            (lhs_idx + i) < lhs.size() && 
            (rhs_idx + i) < rhs.size()
            )
        {
            std::string ltok = lhs[lhs_idx + i];
            std::string rtok = rhs[rhs_idx + i];
            uint64_t I = rhs.size(); // Math.min(lhs.size,rhs.size) //
            const std::string& etok_rhs = end_scope[etok_lhs];
            while (i++ < I) {
                if (ltok != rtok) {
                    sat = false;
                    break;
                }
                if (rtok == etok_rhs) {
                    break;
                }
                ltok = lhs[lhs_idx + i];
                rtok = rhs[rhs_idx + i];
            }
        } else {
            sat = false;
        }
    } // test(etok_lhs) //
    return sat;
}
/*
  vector<string> tokens;

  // Iterate over the tokens.
  for (const auto& token : tokens) {
    // If the token is an equals sign and the compound flag is not set,
    // reset the index.
    if (token == "=" && !COMPOUND) {
      jdx = 0;
    }

    // If the scope is satisfied,
    if (_scope_satisfied(token, me, idx, from, jdx)) {
      // Add the index to the vector of keys.
      vkeys.push_back(idx);

      // If the index is equal to the size of the from array,
      if (++jdx == from.size) {
        // Set the subnetFOUND flag to true.
        _subnetFOUND = true;

        // Iterate over the keys.
        for (const auto& kdx : vkeys) {
          // Add the sub tag to the HTML pre element at the key index.
          tmpHTML.pre[kdx] += _id.addTAG("sub");

          // Set the HTML post element at the key index to null.
          tmpHTML.post[kdx] = nullptr;

          // Set the HTMLR post element at the key index to null.
          tmpHTMLR.post[kdx] = nullptr;

          // Set the Proof element at the key index to null.
          Proof[kdx] = nullptr;

          // If the index is equal to 0,
          if (ii == 0) {
            // Set the HTML post element at the key index to the result of
            // joining the to array with the sub tag.
            tmpHTML.post[kdx] = to.map([](const auto& atok) {
              return (atok + _id.addTAG("sub"));
            }).join(" ");

            // Set the HTMLR post element at the key index to the result of
            // joining the to array with a space.
            tmpHTMLR.post[kdx] = to.join(' ');

            // Set the Proof element at the key index to the result of
            // joining the to array with a space.
            Proof[kdx] = to.join(" ");
          }
        }

        // Reset the index.
        jdx = 0;

        // Clear the vector of keys.
        vkeys.clear();
      }
    }
  }
*/

    bool bRewriteFlag {true};

        if (
            val == from[I] /*&& 
            end_scope.find(val) == end_scope.end()*/
            )
        {
            if (bRewriteFlag)
            {
                i = I;
                bRewriteFlag = false;
                /*
                for (const auto& val2 : to)
                {
                    ++j;
                    result.emplace_back (val2);
                }*/
            }
            ++I;
        } else {
            result.emplace_back (val);
        }
