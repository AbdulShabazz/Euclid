_
Build EuclidProverLib as a DLL (to debug), only export LIB and C++20 headers for use in static builds (Performance). Or export C++17 compliant source.

Algorithm

	Step 0 // Add only unique axiom_ and lemma_ signatures...

	Step 1 // Separate lhs/rhs
		axiom_0[lhs,=,rhs] ... >> { axiom_0: [lhs] }, { axiom_0: [rhs] } ... { axiom_M: [lhs] }, { axiom_M: [rhs] }
		lemma_0[lhs,=,rhs] ... >> { lemma_0: [lhs] }, { lemma_0: [rhs] } ... { lemma_N: [lhs] }, { lemma_N: [rhs] }
		ProofTarget[lhs,=,rhs] ... >> { ProofTarget: [lhs] }, { ProofTarget: [rhs] } ...

	Step 2 // Construct additional lemmas
		iff { [axiom/lemma]_[m/n]: [lhs/rhs] } in { [axiom/lemma]_![m/n]: [rhs/lhs] } >> { lemma_k: [rhs/lhs] }, where m in M; n in N; k > M + N

	Optional Step 3 Prove Via (Reduce, Expand, Reduce + Expand)
		spawn_thread iff: Step 3 Reduce, repeat Step 3 Reduce
		spawn_thread iff: Step 3 Expand, repeat Step 3 Expand
		spawn_thread iff: Step 3 Reduce and or Step 3 Expand, repeat Step 3 Reduce and or Step 3 Expand

	Optional Step 3 Prove Via Reduce // Find a substitution candidate (find longer > shorter)
	spawn_thread iff: { [axiom/lemma]_[m/n]: [lhs/rhs] } in { ProofTarget: [lhs/rhs] }
		if { ProofTarget: [lhs] } == { ProofTarget: [rhs] } Proof found
		if { ProofTarget: [lhs] } != { ProofTarget: [rhs] } repeat Step 3 Reduce

	Optional Step 3 Prove Via Expand // Find a substitution candidate (shorter > longer)
	spawn_thread iff: { [axiom/lemma]_[m/n]: [lhs/rhs] } in { ProofTarget: [lhs/rhs] }
		if { ProofTarget: [lhs] } == { ProofTarget: [rhs] }, Proof found
		if { ProofTarget: [lhs] } != { ProofTarget: [rhs] }, repeat Step 3 Expand

NOTES

To improve performance, Proof-search is conducted on arrays of primes. 

	Example:

		// Brackets '{} [] ()' and Equals '=' are builtin reserved types
		tokens: '{', '}', '1', '2', '+', '='
		primes:  2,   3,   7,  11,  13,   5

But how to represent the proof-search space internally?	

	Solution: (abandoned)

		// As simple strings or arrays of strings
		prove: { 1 } + { 1 } = { 2 }

		Limitations: parsing an array of tokens as strings or integers within loop-constructs offers untenable quadratic runtime performance
	
	Solution: (abandoned)

		// prime number internal representation with place-value exponents
		2^1 * 7^2 * 3^3 * 13^4 * 2^5 * 7^6 * 3^7 * 5^8 * 2^9 * 11^10 * 3^11... 

		Limitations: overflow
	
	Solution: (abandoned)

		// scale-invariant internal string representation: 
		'2_1 7_2 3_3 13_4 2_5 7_6 3_7 5_8 2_9 11_10 3_11'

		Limitations: pattern searching over long strings

	Solution: (abandoned)

		// Overall BigInt support (__x86i64Int ) 
		2^1 * 7^2 * 3^3 * 13^4 * 2^5 * 7^6 * 3^7 * 5^8 * 2^9 * 11^10 * 3^11...

		Limitations: Low multiplication performance

	Solution: (abandoned)

		// PrimeNumber only BigInt support (__x86i64Int ) 
		2^1 * 7^2 * 3^3 * 13^4 * 2^5 * 7^6 * 3^7 * 5^8 * 2^9 * 11^10 * 3^11...

		// Internal log2 support (unsigned double precision) 
		0.69314718055994530941723212145818 +
		3.8918202981106266102107054868864 +
		3.2958368660043290741857357107676 +
		* 13^4 * 2^5 * 7^6 * 3^7 * 5^8 * 2^9 * 11^10 * 3^11...

		std::pair<double, double> Number = std::log2(2^1 * 7^2 * 3^3 * 13^4 * 2^5 * 7^6 * 3^7 * 5^8 * 2^9 * 11^10 * 3^11...)

		Number.first; // Integer part
		Number.second; // Fractional part

		std::unordered_set NumberSet{}
		NumberSet.insert(Number.first)
		NumberSet.insert(Number.second) // Is there enough variance to rely only on Number.second?

		// iff Number.second == 0.0, then rely on Number.first ?

		Limitations: Set inclusion requires combinatorial expansion (ie. combinatorial explosion)

	Solution: (abandoned)

		// Overall builtin support (uint64_t) with BigInt support (__x86i64Int ) as needed
		2^1 * 7^2 * 3^3 * 13^4 * 2^5 * 7^6 * 3^7 * 5^8 * 2^9 * 11^10 * 3^11...

		Limitations: non-exceptional multiplication performance		

	Solution: (abandoned)

		// Managing (uint64_t) single- byte words 
		 2 3 5 7 11 13...
		[1 1 1 1 1  1]

		Limitations: token order not preserved

	Solution: (in-process)

		// Managing (uint64_t) multi-byte words % num_tokens
		 2 3 5 7 11 13  2 3 5 7 11 13  2 3 5 7 11 13...
		[1 0 0 0 0  0] [0 0 0 1 0  0] [0 1 0 0 0  0]

		Limitations: token order not preserved

Todo: Add an optional constraint flag parameter to axioms and or lemmas to require or ignore their use
Todo: Cache axioms-, lemmas-, intermedite results-, proof statements- and their proofsteps-, to disk, for ready retrieval when game play conditions re-present themselves (perhaps using a cocktail of thread-management and async co-routines)
Todo: Implement the proof-search and caching algorithm using (async) co_routines and use threadpools for the nextprime computation.
Todo: convert data types to auto to allow the theorem prover that is the compiler to perform optimizations on the data types.

NOTES
[+] Add a strict specifier, eg. st{ { 2 } - { 1 } } = { 1 }